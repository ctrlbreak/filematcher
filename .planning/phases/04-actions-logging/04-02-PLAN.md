---
phase: 04-actions-logging
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - file_matcher.py
autonomous: true

must_haves:
  truths:
    - "Every execution creates a log file with timestamps"
    - "Log includes action type, file paths, and result for each operation"
    - "User can specify custom log path with --log flag"
    - "Log has header with run info and footer with summary"
  artifacts:
    - path: "file_matcher.py"
      provides: "Audit logging functions"
      exports: ["create_audit_logger", "log_operation", "write_log_header", "write_log_footer"]
  key_links:
    - from: "create_audit_logger()"
      to: "logging.FileHandler"
      via: "log file creation"
      pattern: "FileHandler.*log_path"
    - from: "log_operation()"
      to: "audit_logger.info()"
      via: "log entry writing"
      pattern: "audit_logger.*info"
---

<objective>
Implement the audit logging system that records all file modifications with timestamps, paths, and results.

Purpose: Provides a complete audit trail of all changes made during execution. Users need this for verification and potential manual recovery. Logs are the safety net for deduplication operations.

Output: Functions for log file creation, per-operation logging, and summary generation. Support for `--log` flag.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-actions-logging/04-CONTEXT.md
@.planning/phases/04-actions-logging/04-RESEARCH.md
@file_matcher.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement audit logging functions</name>
  <files>file_matcher.py</files>
  <action>
Add datetime import at top of file if not present (it's not):
```python
from datetime import datetime
```

Add the following functions after the execute_all_actions() function (or after format_file_size() if plan 01 not yet executed):

1. `create_audit_logger(log_path: Path | None = None) -> tuple[logging.Logger, Path]`:
   - If log_path is None, generate default: `filematcher_YYYYMMDD_HHMMSS.log` in current directory
   - Use datetime.now().strftime("%Y%m%d_%H%M%S") for timestamp
   - Create a new logger named 'filematcher.audit' (separate from main logger)
   - Use logging.FileHandler with utf-8 encoding
   - Set formatter to just '%(message)s' (plain text, we handle formatting)
   - Return (logger, actual_log_path)

2. `write_log_header(audit_logger: logging.Logger, dir1: str, dir2: str, master: str, action: str, flags: list[str]) -> None`:
   - Write header block to log:
   ```
   ================================================================================
   File Matcher Execution Log
   ================================================================================
   Timestamp: {ISO 8601 timestamp}
   Directories: {dir1}, {dir2}
   Master: {master}
   Action: {action}
   Flags: {', '.join(flags)}
   ================================================================================

   ```
   - Use datetime.now().isoformat() for timestamp

3. `log_operation(audit_logger: logging.Logger, action: str, duplicate: str, master: str, file_size: int, file_hash: str, success: bool, error: str = "") -> None`:
   - Write single operation line:
   - Format: `[{timestamp}] {ACTION} {duplicate} -> {master} ({size}) [{hash_prefix}...] {RESULT}`
   - timestamp: datetime.now().isoformat()
   - ACTION: action.upper()
   - size: Use format_file_size()
   - hash_prefix: First 8 chars of hash
   - RESULT: "SUCCESS" or "FAILED: {error}"
   - For delete action, use "DELETED" instead of "->" format

4. `write_log_footer(audit_logger: logging.Logger, success_count: int, failure_count: int, skipped_count: int, space_saved: int, failed_list: list[tuple[str, str]]) -> None`:
   - Write footer block:
   ```

   ================================================================================
   Summary
   ================================================================================
   Total files processed: {success + failure + skipped}
   Successful: {success_count}
   Failed: {failure_count}
   Skipped: {skipped_count}
   Space saved: {format_file_size(space_saved)}

   {If failed_list:}
   Failed files:
     - {path}: {error}
     ...
   ================================================================================
   ```
  </action>
  <verify>
Add temporary test code:
```python
if __name__ == "__main__" and len(sys.argv) > 1 and sys.argv[1] == "--test-logging":
    import tempfile
    with tempfile.TemporaryDirectory() as tmpdir:
        log_path = Path(tmpdir) / "test.log"
        audit, actual = create_audit_logger(log_path)
        write_log_header(audit, "/dir1", "/dir2", "/dir1", "hardlink", ["--execute", "--verbose"])
        log_operation(audit, "hardlink", "/dir2/dup.txt", "/dir1/master.txt", 1024, "abc123def456", True)
        log_operation(audit, "hardlink", "/dir2/dup2.txt", "/dir1/master.txt", 2048, "xyz789", False, "Permission denied")
        write_log_footer(audit, 1, 1, 0, 1024, [("/dir2/dup2.txt", "Permission denied")])
        print(log_path.read_text())
```
Run: `python file_matcher.py --test-logging`
Verify output shows proper header, operations, and footer.
Remove test code after verification.
  </verify>
  <done>
- create_audit_logger() creates separate file logger with default naming
- write_log_header() writes run information
- log_operation() writes timestamped operation lines
- write_log_footer() writes summary with failed files list
  </done>
</task>

<task type="auto">
  <name>Task 2: Add --log CLI flag</name>
  <files>file_matcher.py</files>
  <action>
In main() function, add the --log argument after the --yes argument:

```python
parser.add_argument('--log', '-l', type=str, metavar='PATH',
                    help='Path for audit log file (default: filematcher_YYYYMMDD_HHMMSS.log)')
```

This flag is only used during execution (--execute mode). The actual integration with execute_all_actions() will be done in plan 04-03.

Validate that --log makes sense (cannot be used without --execute):
```python
# After existing validations
if args.log and not args.execute:
    parser.error("--log requires --execute")
```
  </action>
  <verify>
Test CLI flag parsing:
```bash
python file_matcher.py test_dir1 test_dir2 --master test_dir1 --action hardlink --log test.log
# Should show preview (no error about unrecognized argument)

python file_matcher.py test_dir1 test_dir2 --log test.log
# Should error: "--log requires --execute"
```
  </verify>
  <done>
- --log/-l flag added to argparse
- Validation ensures --log requires --execute
- Flag accepts custom path for log file
  </done>
</task>

</tasks>

<verification>
- [ ] datetime imported at top of file
- [ ] Audit logger functions implemented
- [ ] Log format matches CONTEXT.md specification
- [ ] --log flag added with proper validation
- [ ] All 64 existing tests still pass
</verification>

<success_criteria>
1. `create_audit_logger()` creates file logger with default naming convention
2. `write_log_header()` outputs run information in specified format
3. `log_operation()` logs each operation with timestamp, paths, size, hash, result
4. `write_log_footer()` outputs summary with totals and failed file list
5. `--log` flag accepts custom path and validates --execute requirement
6. All existing tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/04-actions-logging/04-02-SUMMARY.md`
</output>
