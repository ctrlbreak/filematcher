---
phase: 04-actions-logging
plan: 03
type: execute
wave: 2
depends_on: ["04-01", "04-02"]
files_modified:
  - file_matcher.py
autonomous: true

must_haves:
  truths:
    - "Running with --execute actually modifies files"
    - "Confirmation prompt shows summary with space savings"
    - "Delete action shows extra irreversibility warning"
    - "Progress is displayed during execution"
    - "--fallback-symlink converts cross-fs hardlinks to symlinks"
  artifacts:
    - path: "file_matcher.py"
      provides: "Complete execution integration"
      exports: ["format_confirmation_prompt"]
  key_links:
    - from: "main() execute branch"
      to: "execute_all_actions()"
      via: "confirmation then execution"
      pattern: "execute_all_actions.*duplicate_groups"
    - from: "execute_all_actions()"
      to: "log_operation()"
      via: "logging each action"
      pattern: "log_operation.*audit"
---

<objective>
Integrate the action execution engine with the CLI, replacing the placeholder "Execution not yet implemented" message with actual file modifications.

Purpose: This plan wires together plans 01 and 02 into the main() function, enabling the tool to actually perform deduplication. Includes --fallback-symlink flag, enhanced confirmation, and progress output.

Output: Fully functional execution mode that modifies files, logs operations, and reports results.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-actions-logging/04-CONTEXT.md
@.planning/phases/04-actions-logging/04-RESEARCH.md
@.planning/phases/04-actions-logging/04-01-SUMMARY.md
@.planning/phases/04-actions-logging/04-02-SUMMARY.md
@file_matcher.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add --fallback-symlink flag and enhanced confirmation</name>
  <files>file_matcher.py</files>
  <action>
1. Add --fallback-symlink flag to argparse (after --log):
```python
parser.add_argument('--fallback-symlink', action='store_true',
                    help='Use symlink instead of hardlink for cross-filesystem duplicates')
```

2. Add validation that --fallback-symlink only makes sense with hardlink action:
```python
if args.fallback_symlink and args.action != 'hardlink':
    parser.error("--fallback-symlink only applies to --action hardlink")
```

3. Create `format_confirmation_prompt(duplicate_count: int, action: str, space_savings: int, cross_fs_count: int = 0) -> str`:
   - Format: "{count} files will be {action_verb}. ~{space} will be saved. Proceed? [y/N]"
   - action_verb mapping:
     - hardlink: "replaced with hard links"
     - symlink: "replaced with symbolic links"
     - delete: "permanently deleted"
   - For delete action, add prefix: "WARNING: This action is IRREVERSIBLE.\n"
   - If cross_fs_count > 0 and action == hardlink: append note about fallback-symlink usage

4. Update confirm_execution() signature to accept a custom prompt:
```python
def confirm_execution(skip_confirm: bool = False, prompt: str = "Proceed? [y/N] ") -> bool:
```
Then update the input() call to use the prompt parameter.
  </action>
  <verify>
Test flag parsing:
```bash
python file_matcher.py test_dir1 test_dir2 --master test_dir1 --action hardlink --fallback-symlink
# Should show preview without error

python file_matcher.py test_dir1 test_dir2 --master test_dir1 --action symlink --fallback-symlink
# Should error: "--fallback-symlink only applies to --action hardlink"
```
  </verify>
  <done>
- --fallback-symlink flag added with validation
- format_confirmation_prompt() generates action-specific prompts
- Delete action shows irreversibility warning
- confirm_execution() accepts custom prompt string
  </done>
</task>

<task type="auto">
  <name>Task 2: Integrate execution into main()</name>
  <files>file_matcher.py</files>
  <action>
Replace the placeholder execution code in main() (the section that says "Execution not yet implemented") with actual execution:

1. After confirmation is accepted in execute_mode branch:

```python
# Create audit logger
log_path = Path(args.log) if args.log else None
audit_logger, actual_log_path = create_audit_logger(log_path)

# Build flags list for log header
flags = ['--execute']
if args.verbose:
    flags.append('--verbose')
if args.yes:
    flags.append('--yes')
if args.fallback_symlink:
    flags.append('--fallback-symlink')
if args.log:
    flags.append(f'--log {args.log}')

# Write log header
write_log_header(audit_logger, args.dir1, args.dir2, args.master, args.action, flags)

# Execute actions with logging callback
# Need to modify execute_all_actions to accept audit_logger
# OR create wrapper that logs each operation
```

2. The execute_all_actions() function needs to be updated to accept an audit_logger parameter and call log_operation() for each action. Add these parameters:
   - audit_logger: logging.Logger | None = None
   - file_hashes: dict[str, str] | None = None  # Hash lookup for logging

   Inside the loop, after each execute_action() call:
   ```python
   if audit_logger:
       file_size = os.path.getsize(master) if os.path.exists(master) else 0
       file_hash = file_hashes.get(duplicate, "unknown") if file_hashes else "unknown"
       log_operation(audit_logger, actual_action, duplicate, master, file_size, file_hash, success, error)
   ```

3. After execution completes:
   - Calculate actual space saved (sum of sizes for successful operations)
   - Write log footer with results
   - Print summary to stdout
   - Return appropriate exit code using determine_exit_code()

4. Update confirmation to use enhanced prompt:
```python
bytes_saved, dup_count, _ = calculate_space_savings(master_results)
prompt = format_confirmation_prompt(dup_count, args.action, bytes_saved, len(cross_fs_files))
if not confirm_execution(skip_confirm=args.yes, prompt=prompt):
    print("Aborted. No changes made.")
    return 0
```

5. Print execution summary after completion:
```python
print()
print(f"Execution complete:")
print(f"  Successful: {success_count}")
print(f"  Failed: {failure_count}")
print(f"  Skipped: {skipped_count}")
print(f"  Log file: {actual_log_path}")
if failed_list:
    print()
    print("Failed files:")
    for path, error in failed_list:
        print(f"  - {path}: {error}")
```
  </action>
  <verify>
Create test directories and run actual execution:
```bash
# Setup test
mkdir -p /tmp/fm_test/master /tmp/fm_test/dups
echo "content" > /tmp/fm_test/master/file1.txt
echo "content" > /tmp/fm_test/dups/dup1.txt
echo "content" > /tmp/fm_test/dups/dup2.txt

# Run with hardlink
python file_matcher.py /tmp/fm_test/master /tmp/fm_test/dups --master /tmp/fm_test/master --action hardlink --execute --yes

# Verify hardlinks created
ls -li /tmp/fm_test/master/file1.txt /tmp/fm_test/dups/dup1.txt /tmp/fm_test/dups/dup2.txt
# Inode numbers should match

# Check log file was created
ls filematcher_*.log
cat filematcher_*.log

# Cleanup
rm -rf /tmp/fm_test filematcher_*.log
```
  </verify>
  <done>
- Execution branch calls execute_all_actions() with logging
- Audit log is created and populated
- Enhanced confirmation prompt with space savings
- Delete action shows irreversibility warning
- Progress displayed during execution (via execute_all_actions verbose)
- Summary printed after completion
- Correct exit code returned
  </done>
</task>

<task type="auto">
  <name>Task 3: Wire file hashes for logging</name>
  <files>file_matcher.py</files>
  <action>
The log format requires file hashes for each operation. The hashes are already computed during find_matching_files() but not retained in a usable form.

1. Create a hash lookup dict in main() when processing master_results:
```python
# Build hash lookup for logging (hash -> first file with that hash)
# This is available from the matches dict key
file_hash_lookup = {}
for file_hash, (files1, files2) in matches.items():
    for f in files1 + files2:
        file_hash_lookup[f] = file_hash
```

2. Pass this to execute_all_actions():
```python
success_count, failure_count, skipped_count, failed_list = execute_all_actions(
    master_results,
    args.action,
    fallback_symlink=args.fallback_symlink,
    verbose=args.verbose,
    audit_logger=audit_logger,
    file_hashes=file_hash_lookup
)
```

3. Track actual space saved (not estimated):
   - In execute_all_actions(), track sizes of successfully processed files
   - Return space_saved as additional return value
   - Update function signature: `-> tuple[int, int, int, int, list[tuple[str, str]]]`
     (success_count, failure_count, skipped_count, space_saved, failed_list)
  </action>
  <verify>
Run execution and check log file contains actual hashes:
```bash
mkdir -p /tmp/fm_test/master /tmp/fm_test/dups
echo "content" > /tmp/fm_test/master/file1.txt
echo "content" > /tmp/fm_test/dups/dup1.txt

python file_matcher.py /tmp/fm_test/master /tmp/fm_test/dups --master /tmp/fm_test/master --action hardlink --execute --yes --log /tmp/fm_test/test.log

cat /tmp/fm_test/test.log
# Should show actual hash prefix in log entries, not "unknown"

rm -rf /tmp/fm_test
```
Run all tests: `python3 run_tests.py` - should still pass 64 tests.
  </verify>
  <done>
- File hashes passed to execution for logging
- Actual space saved tracked during execution
- Log entries contain real hash prefixes
- All existing tests still pass
  </done>
</task>

</tasks>

<verification>
- [ ] --fallback-symlink flag works correctly
- [ ] Confirmation prompt shows file count and space savings
- [ ] Delete action shows irreversibility warning
- [ ] Execution actually modifies files
- [ ] Log file created with header, operations, and footer
- [ ] Correct exit code returned (0, 1, or 3)
- [ ] All 64 existing tests still pass
</verification>

<success_criteria>
1. `filematcher dir1 dir2 --master dir1 --action hardlink --execute` creates hard links
2. `filematcher dir1 dir2 --master dir1 --action symlink --execute` creates symbolic links
3. `filematcher dir1 dir2 --master dir1 --action delete --execute` deletes duplicates
4. Log file contains complete audit trail
5. Confirmation shows summary before proceeding
6. Exit code reflects execution result
7. All existing tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/04-actions-logging/04-03-SUMMARY.md`
</output>
