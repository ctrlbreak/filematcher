---
phase: 01-master-directory-foundation
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - file_matcher.py
autonomous: true

must_haves:
  truths:
    - "User can run `filematcher dir1 dir2 --master dir1` and tool accepts it"
    - "User receives error if --master points to a directory not being compared"
    - "Output labels files as master or duplicate based on directory"
    - "Duplicates within master directory resolve by timestamp (oldest = master)"
    - "Summary mode shows master/duplicate counts"
  artifacts:
    - path: "file_matcher.py"
      provides: "--master flag, validation, and output formatting"
      contains: "parser.add_argument.*--master"
  key_links:
    - from: "main()"
      to: "validate_master_directory()"
      via: "function call after argparse"
      pattern: "validate_master_directory.*args\\.master"
    - from: "main()"
      to: "output formatting"
      via: "master-aware print statements"
      pattern: "master.*->"
---

<objective>
Implement the `--master` flag for designating a master directory, including path validation and master-aware output formatting.

Purpose: Establishes the master/duplicate concept that Phase 2 (dry-run) and Phase 3 (actions) will build upon. Without this, users cannot indicate which files should be preserved.

Output: Modified `file_matcher.py` with working `--master` flag, validation, and labeled output showing master files vs duplicates.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/01-master-directory-foundation/01-CONTEXT.md
@.planning/phases/01-master-directory-foundation/01-RESEARCH.md
@file_matcher.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add --master flag and validation</name>
  <files>file_matcher.py</files>
  <action>
Add the `--master` flag to argparse and implement validation:

1. Add argument to parser:
   ```python
   parser.add_argument('--master', '-m',
                       help='Designate one directory as master (files in master are never modified)')
   ```

2. Create `validate_master_directory()` function:
   - Takes `master: str`, `dir1: str`, `dir2: str` parameters
   - Uses `Path.resolve()` to canonicalize all paths (handles `./`, `../`, symlinks)
   - Returns resolved master path if it matches dir1 or dir2
   - Raises `ValueError` with message "Master must be one of the compared directories"

3. In `main()`, after `args = parser.parse_args()`:
   - If `args.master` is set, call `validate_master_directory()`
   - Catch `ValueError` and call `parser.error(str(e))` (exits with code 2)
   - Store the resolved master path for use in output formatting

Pattern from RESEARCH.md:
```python
def validate_master_directory(master: str, dir1: str, dir2: str) -> Path:
    master_resolved = Path(master).resolve()
    dir1_resolved = Path(dir1).resolve()
    dir2_resolved = Path(dir2).resolve()

    if master_resolved == dir1_resolved or master_resolved == dir2_resolved:
        return master_resolved
    raise ValueError("Master must be one of the compared directories")
```
  </action>
  <verify>
Run manually:
```bash
cd /Users/patrick/dev/cursor_projects/filematcher
# Valid master - should work
python file_matcher.py test_dir1 test_dir2 --master test_dir1

# Invalid master - should exit 2 with error
python file_matcher.py test_dir1 test_dir2 --master /tmp && echo "FAIL: should have errored"
echo "Exit code: $?"
```
  </verify>
  <done>
`--master` flag accepted by argparse. Valid master path (matching dir1 or dir2) passes validation. Invalid master path produces error message to stderr and exits with code 2.
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement master-aware output formatting</name>
  <files>file_matcher.py</files>
  <action>
Modify output to distinguish master files from duplicates when `--master` is set:

1. Create helper function `select_master_file(file_paths: list[str], master_dir: Path) -> tuple[str, list[str]]`:
   - Separate files into master_dir files and non-master files
   - If multiple files in master_dir with same content: use `os.path.getmtime()` to pick oldest as the "true master"
   - Return `(master_file, duplicate_files)` tuple
   - If no files in master_dir (all duplicates are outside master): pick oldest file overall as master

2. Create helper function `format_master_output(master_file: str, duplicates: list[str]) -> str`:
   - Returns arrow notation: `{master_file} -> {dup1}, {dup2}, ...`

3. Modify `main()` output section:
   - When `--master` is set AND matches found:
     - For each hash group, call `select_master_file()` to determine master
     - Print using arrow notation instead of current grouped format
     - If multiple files in master directory with same content, print warning: "Warning: Multiple files in master directory have identical content: {paths}"
   - When `--master` is NOT set: preserve current output format exactly

4. Modify `--summary` mode when `--master` is set:
   - Add counts: "X master files, Y duplicates"
   - Keep existing counts as well

5. Modify `--verbose` mode when `--master` is set:
   - For each group, show which file was chosen as master and why
   - Format: "Selected master: {path} (oldest in master directory)" or "Selected master: {path} (only file in master directory)"

6. Handle edge case - no duplicates found:
   - Print "No duplicates found" and exit 0 (preserve current behavior)
  </action>
  <verify>
Run manually with various flag combinations:
```bash
cd /Users/patrick/dev/cursor_projects/filematcher

# Basic master mode - check arrow notation
python file_matcher.py test_dir1 test_dir2 --master test_dir1

# Summary mode with master
python file_matcher.py test_dir1 test_dir2 --master test_dir1 --summary

# Verbose mode with master
python file_matcher.py test_dir1 test_dir2 --master test_dir1 --verbose

# Without master - should show old format
python file_matcher.py test_dir1 test_dir2

# With unmatched files
python file_matcher.py test_dir1 test_dir2 --master test_dir1 --show-unmatched
```

Check output shows:
- Arrow notation when --master set
- "X master files, Y duplicates" in summary mode
- Resolution reasoning in verbose mode
  </verify>
  <done>
Output with `--master` uses arrow notation (`/master/file -> /dup/file1, /dup/file2`). Summary mode shows master/duplicate counts. Verbose mode shows which file was chosen as master and why. Output without `--master` unchanged from current behavior.
  </done>
</task>

</tasks>

<verification>
After both tasks complete:

1. Validation works correctly:
```bash
# These should succeed (exit 0)
python file_matcher.py test_dir1 test_dir2 --master test_dir1
python file_matcher.py test_dir1 test_dir2 --master ./test_dir1
python file_matcher.py test_dir1 test_dir2 -m test_dir2

# These should fail (exit 2)
python file_matcher.py test_dir1 test_dir2 --master /nonexistent
python file_matcher.py test_dir1 test_dir2 --master /tmp
```

2. Output formatting correct:
- With `--master`: arrow notation visible
- With `--master --summary`: master/duplicate counts shown
- With `--master --verbose`: resolution reasoning shown
- Without `--master`: original output format preserved

3. Edge cases:
- Relative paths resolve correctly
- Symlinked paths resolve correctly
- No duplicates found message works
</verification>

<success_criteria>
- MSTR-01: `--master` flag works and accepts path argument
- MSTR-02: Foundation for protection (files are labeled, not modified - Phase 1 has no actions)
- MSTR-03: Validation rejects invalid master paths with clear error
- Output clearly distinguishes master files from duplicates
- All existing tests still pass (`python3 run_tests.py`)
</success_criteria>

<output>
After completion, create `.planning/phases/01-master-directory-foundation/01-01-SUMMARY.md`
</output>
