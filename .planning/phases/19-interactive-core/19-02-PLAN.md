---
phase: 19-interactive-core
plan: 02
type: execute
wave: 2
depends_on: ["19-01"]
files_modified:
  - tests/test_interactive.py
autonomous: true

must_haves:
  truths:
    - "Response 'y' leads to group execution"
    - "Response 'n' skips group without execution"
    - "Response 'a' executes current and auto-confirms remaining"
    - "Response 'q' stops loop with no further prompts"
    - "Invalid input re-prompts (does not crash)"
    - "Case variations (Y, YES, Yes) all work"
  artifacts:
    - path: "tests/test_interactive.py"
      provides: "Unit tests for interactive_execute, prompt_for_group, _normalize_response"
      min_lines: 100
  key_links:
    - from: "tests/test_interactive.py"
      to: "filematcher/cli.py:interactive_execute"
      via: "unittest with mocked input"
      pattern: "from filematcher.cli import interactive_execute"
---

<objective>
Add comprehensive unit tests for the interactive confirmation loop functions.

Purpose: Ensure interactive_execute(), prompt_for_group(), and _normalize_response() behave correctly across all response types and edge cases.

Output: New test module tests/test_interactive.py with tests for all y/n/a/q responses, case handling, and invalid input re-prompting.
</objective>

<execution_context>
@/Users/patrick/.claude/get-shit-done/workflows/execute-plan.md
@/Users/patrick/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/19-interactive-core/19-CONTEXT.md
@.planning/phases/19-interactive-core/19-RESEARCH.md
@.planning/phases/19-interactive-core/19-01-SUMMARY.md
@filematcher/cli.py
@tests/test_formatters.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create test_interactive.py with response normalization tests</name>
  <files>tests/test_interactive.py</files>
  <action>
Create tests/test_interactive.py with tests for _normalize_response():

```python
"""Tests for interactive confirmation loop functions."""

from __future__ import annotations

import unittest
from unittest.mock import patch, MagicMock
import io
import sys
import os
import tempfile

from filematcher.cli import (
    _normalize_response,
    prompt_for_group,
    interactive_execute,
)
from filematcher.types import Action, DuplicateGroup
from filematcher.formatters import TextActionFormatter
from filematcher.colors import ColorConfig, ColorMode


class TestNormalizeResponse(unittest.TestCase):
    """Tests for _normalize_response() helper."""

    def test_yes_responses(self):
        """Test all 'yes' variants normalize to 'y'."""
        for response in ['y', 'Y', 'yes', 'YES', 'Yes', 'yEs']:
            with self.subTest(response=response):
                self.assertEqual(_normalize_response(response), 'y')

    def test_no_responses(self):
        """Test all 'no' variants normalize to 'n'."""
        for response in ['n', 'N', 'no', 'NO', 'No', 'nO']:
            with self.subTest(response=response):
                self.assertEqual(_normalize_response(response), 'n')

    def test_all_responses(self):
        """Test all 'all' variants normalize to 'a'."""
        for response in ['a', 'A', 'all', 'ALL', 'All', 'aLl']:
            with self.subTest(response=response):
                self.assertEqual(_normalize_response(response), 'a')

    def test_quit_responses(self):
        """Test all 'quit' variants normalize to 'q'."""
        for response in ['q', 'Q', 'quit', 'QUIT', 'Quit', 'qUiT']:
            with self.subTest(response=response):
                self.assertEqual(_normalize_response(response), 'q')

    def test_invalid_responses(self):
        """Test invalid responses return None."""
        for response in ['', ' ', 'x', 'maybe', 'yy', 'nn', 'help', '1', 'true']:
            with self.subTest(response=response):
                self.assertIsNone(_normalize_response(response))

    def test_whitespace_handling(self):
        """Test that casefold handles input correctly."""
        # Note: prompt_for_group strips whitespace, but _normalize_response doesn't
        # So 'y ' with trailing space would fail
        self.assertIsNone(_normalize_response('y '))
        self.assertIsNone(_normalize_response(' y'))


if __name__ == '__main__':
    unittest.main()
```

This establishes the test file structure. Run to verify:
`python3 -m tests.test_interactive`
  </action>
  <verify>
Run: `python3 -m tests.test_interactive` - All tests pass
Run: `python3 run_tests.py` - Test count increases, all pass
  </verify>
  <done>Test file created with comprehensive _normalize_response tests covering all valid and invalid inputs</done>
</task>

<task type="auto">
  <name>Task 2: Add prompt_for_group tests</name>
  <files>tests/test_interactive.py</files>
  <action>
Add TestPromptForGroup class to tests/test_interactive.py after TestNormalizeResponse:

```python
class TestPromptForGroup(unittest.TestCase):
    """Tests for prompt_for_group() function."""

    def setUp(self):
        """Create formatter for tests."""
        self.formatter = TextActionFormatter(
            verbose=False,
            preview_mode=False,
            action='hardlink',
            color_config=ColorConfig(mode=ColorMode.NEVER)
        )

    def test_valid_response_returns_immediately(self):
        """Valid first response returns without re-prompting."""
        with patch('builtins.input', return_value='y'):
            result = prompt_for_group(self.formatter, 1, 5, 'hardlink')
            self.assertEqual(result, 'y')

    def test_invalid_then_valid_reprompts(self):
        """Invalid input shows error and re-prompts."""
        responses = iter(['invalid', 'y'])
        captured_output = io.StringIO()

        with patch('builtins.input', side_effect=lambda _: next(responses)):
            with patch('sys.stdout', captured_output):
                result = prompt_for_group(self.formatter, 1, 5, 'hardlink')

        self.assertEqual(result, 'y')
        self.assertIn('Invalid response', captured_output.getvalue())

    def test_multiple_invalid_then_valid(self):
        """Multiple invalid inputs re-prompt until valid."""
        responses = iter(['', 'maybe', 'help', 'n'])
        captured_output = io.StringIO()

        with patch('builtins.input', side_effect=lambda _: next(responses)):
            with patch('sys.stdout', captured_output):
                result = prompt_for_group(self.formatter, 2, 10, 'delete')

        self.assertEqual(result, 'n')
        # Should have printed error 3 times
        self.assertEqual(captured_output.getvalue().count('Invalid response'), 3)

    def test_keyboard_interrupt_propagates(self):
        """KeyboardInterrupt propagates to caller."""
        with patch('builtins.input', side_effect=KeyboardInterrupt):
            with self.assertRaises(KeyboardInterrupt):
                prompt_for_group(self.formatter, 1, 5, 'hardlink')

    def test_eof_error_propagates(self):
        """EOFError propagates to caller."""
        with patch('builtins.input', side_effect=EOFError):
            with self.assertRaises(EOFError):
                prompt_for_group(self.formatter, 1, 5, 'hardlink')

    def test_whitespace_stripped(self):
        """Leading/trailing whitespace is stripped before validation."""
        with patch('builtins.input', return_value='  yes  '):
            result = prompt_for_group(self.formatter, 1, 5, 'symlink')
            self.assertEqual(result, 'y')
```

Note: Tests use ColorMode.NEVER for predictable output (no ANSI codes).
  </action>
  <verify>
Run: `python3 -m tests.test_interactive` - All tests pass including new class
  </verify>
  <done>prompt_for_group tests cover valid responses, re-prompting, and exception propagation</done>
</task>

<task type="auto">
  <name>Task 3: Add interactive_execute integration tests</name>
  <files>tests/test_interactive.py</files>
  <action>
Add TestInteractiveExecute class to tests/test_interactive.py:

```python
class TestInteractiveExecute(unittest.TestCase):
    """Tests for interactive_execute() main loop."""

    def setUp(self):
        """Create test fixtures."""
        self.test_dir = tempfile.mkdtemp()
        self.formatter = TextActionFormatter(
            verbose=False,
            preview_mode=False,
            action='delete',
            color_config=ColorConfig(mode=ColorMode.NEVER)
        )

        # Create test files
        self.master1 = os.path.join(self.test_dir, 'master1.txt')
        self.dup1 = os.path.join(self.test_dir, 'dup1.txt')
        self.master2 = os.path.join(self.test_dir, 'master2.txt')
        self.dup2 = os.path.join(self.test_dir, 'dup2.txt')

        for f in [self.master1, self.dup1, self.master2, self.dup2]:
            with open(f, 'w') as fp:
                fp.write('test content')

        # Create DuplicateGroup tuples
        self.groups = [
            DuplicateGroup(self.master1, [self.dup1], 'test', 'hash1'),
            DuplicateGroup(self.master2, [self.dup2], 'test', 'hash2'),
        ]

    def tearDown(self):
        """Clean up test directory."""
        import shutil
        shutil.rmtree(self.test_dir, ignore_errors=True)

    def test_yes_executes_group(self):
        """'y' response executes the action on that group."""
        responses = iter(['y', 'n'])  # Confirm first, skip second

        with patch('builtins.input', side_effect=lambda _: next(responses)):
            result = interactive_execute(
                groups=self.groups,
                action=Action.DELETE,
                formatter=self.formatter
            )

        success, failure, skipped, space, failed, confirmed, user_skipped = result
        self.assertEqual(confirmed, 1)
        self.assertEqual(user_skipped, 1)
        # First duplicate should be deleted
        self.assertFalse(os.path.exists(self.dup1))
        # Second duplicate should still exist
        self.assertTrue(os.path.exists(self.dup2))

    def test_no_skips_group(self):
        """'n' response skips the group without execution."""
        responses = iter(['n', 'n'])

        with patch('builtins.input', side_effect=lambda _: next(responses)):
            result = interactive_execute(
                groups=self.groups,
                action=Action.DELETE,
                formatter=self.formatter
            )

        success, failure, skipped, space, failed, confirmed, user_skipped = result
        self.assertEqual(confirmed, 0)
        self.assertEqual(user_skipped, 2)
        # Both duplicates should still exist
        self.assertTrue(os.path.exists(self.dup1))
        self.assertTrue(os.path.exists(self.dup2))

    def test_all_confirms_remaining(self):
        """'a' response confirms current and all remaining groups."""
        with patch('builtins.input', return_value='a'):
            result = interactive_execute(
                groups=self.groups,
                action=Action.DELETE,
                formatter=self.formatter
            )

        success, failure, skipped, space, failed, confirmed, user_skipped = result
        self.assertEqual(confirmed, 2)
        self.assertEqual(user_skipped, 0)
        # Both duplicates should be deleted
        self.assertFalse(os.path.exists(self.dup1))
        self.assertFalse(os.path.exists(self.dup2))

    def test_quit_stops_immediately(self):
        """'q' response stops processing without executing remaining."""
        with patch('builtins.input', return_value='q'):
            result = interactive_execute(
                groups=self.groups,
                action=Action.DELETE,
                formatter=self.formatter
            )

        success, failure, skipped, space, failed, confirmed, user_skipped = result
        self.assertEqual(confirmed, 0)
        self.assertEqual(user_skipped, 0)  # Quit is not "skipped"
        # Both duplicates should still exist
        self.assertTrue(os.path.exists(self.dup1))
        self.assertTrue(os.path.exists(self.dup2))

    def test_keyboard_interrupt_handled(self):
        """Ctrl+C stops loop gracefully."""
        with patch('builtins.input', side_effect=KeyboardInterrupt):
            # Should not raise, should return partial results
            result = interactive_execute(
                groups=self.groups,
                action=Action.DELETE,
                formatter=self.formatter
            )

        success, failure, skipped, space, failed, confirmed, user_skipped = result
        # Should return zeros (no groups processed)
        self.assertEqual(confirmed, 0)

    def test_mixed_responses(self):
        """Test y, n, y sequence."""
        # Create 3 groups
        master3 = os.path.join(self.test_dir, 'master3.txt')
        dup3 = os.path.join(self.test_dir, 'dup3.txt')
        with open(master3, 'w') as f:
            f.write('content')
        with open(dup3, 'w') as f:
            f.write('content')

        groups = self.groups + [DuplicateGroup(master3, [dup3], 'test', 'hash3')]
        responses = iter(['y', 'n', 'y'])

        with patch('builtins.input', side_effect=lambda _: next(responses)):
            result = interactive_execute(
                groups=groups,
                action=Action.DELETE,
                formatter=self.formatter
            )

        success, failure, skipped, space, failed, confirmed, user_skipped = result
        self.assertEqual(confirmed, 2)
        self.assertEqual(user_skipped, 1)
        self.assertFalse(os.path.exists(self.dup1))  # y - deleted
        self.assertTrue(os.path.exists(self.dup2))   # n - kept
        self.assertFalse(os.path.exists(dup3))       # y - deleted

    def test_empty_groups_returns_zeros(self):
        """Empty groups list returns all zeros."""
        result = interactive_execute(
            groups=[],
            action=Action.DELETE,
            formatter=self.formatter
        )

        success, failure, skipped, space, failed, confirmed, user_skipped = result
        self.assertEqual(confirmed, 0)
        self.assertEqual(user_skipped, 0)
        self.assertEqual(success, 0)
```

These tests verify the core loop behavior with real file operations.
  </action>
  <verify>
Run: `python3 -m tests.test_interactive` - All tests pass
Run: `python3 run_tests.py` - Full test suite passes, count increased
  </verify>
  <done>interactive_execute tests cover y/n/a/q responses, keyboard interrupt, and mixed sequences</done>
</task>

</tasks>

<verification>
After all tasks:
1. `python3 -m tests.test_interactive` - All tests pass
2. `python3 run_tests.py` - Test count increases by ~20 tests, all pass
3. No existing tests broken (253 original tests still pass)
4. Test coverage includes:
   - _normalize_response: 6 test methods
   - prompt_for_group: 6 test methods
   - interactive_execute: 7 test methods
</verification>

<success_criteria>
- tests/test_interactive.py exists with ~19 test methods
- All response types tested (y, n, a, q and case variants)
- Invalid input re-prompting tested
- Exception handling (KeyboardInterrupt, EOFError) tested
- Full loop behavior tested with actual file operations
- Full test suite passes (253 + ~19 = ~272 tests)
</success_criteria>

<output>
After completion, create `.planning/phases/19-interactive-core/19-02-SUMMARY.md`
</output>
