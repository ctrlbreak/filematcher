---
phase: 19-interactive-core
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - filematcher/cli.py
autonomous: true

must_haves:
  truths:
    - "User can respond y/Y/yes/YES to confirm a group"
    - "User can respond n/N/no/NO to skip a group"
    - "User can respond a/A/all/ALL to confirm current and remaining groups"
    - "User can respond q/Q/quit/QUIT to stop processing"
    - "Invalid input shows error message and re-prompts"
    - "Each confirmed group executes immediately before next group displayed"
    - "space_saved tracks file sizes of successfully processed duplicates"
    - "audit_logger receives log_operation calls for each file action"
  artifacts:
    - path: "filematcher/cli.py"
      provides: "interactive_execute(), prompt_for_group(), _normalize_response()"
      exports: ["interactive_execute", "prompt_for_group"]
  key_links:
    - from: "filematcher/cli.py:interactive_execute"
      to: "filematcher/formatters.py:format_group_prompt"
      via: "formatter method call"
      pattern: "formatter\\.format_group_prompt"
    - from: "filematcher/cli.py:interactive_execute"
      to: "filematcher/actions.py:execute_action"
      via: "execute each confirmed group immediately"
      pattern: "execute_action\\(dup, master_file, action\\.value"
    - from: "filematcher/cli.py:interactive_execute"
      to: "filematcher/actions.py:log_operation"
      via: "audit logging after each action"
      pattern: "log_operation\\(audit_logger"
---

<objective>
Implement core interactive confirmation loop for per-group y/n/a/q prompts.

Purpose: Enable users to confirm or skip each duplicate group individually rather than batch confirmation, matching git add -p UX pattern.

Output: Three new functions in cli.py - `interactive_execute()`, `prompt_for_group()`, `_normalize_response()`
</objective>

<execution_context>
@/Users/patrick/.claude/get-shit-done/workflows/execute-plan.md
@/Users/patrick/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/19-interactive-core/19-CONTEXT.md
@.planning/phases/19-interactive-core/19-RESEARCH.md
@.planning/phases/18-formatter-extensions/18-01-SUMMARY.md
@filematcher/cli.py
@filematcher/formatters.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add response normalization helper</name>
  <files>filematcher/cli.py</files>
  <action>
Add the `_normalize_response()` helper function after the existing `confirm_execution()` function (around line 38).

```python
def _normalize_response(response: str) -> str | None:
    """Normalize user response to single char or None if invalid.

    Accepts: y, yes, n, no, a, all, q, quit (case-insensitive)
    Returns: 'y', 'n', 'a', 'q', or None
    """
    response = response.casefold()
    if response in ('y', 'yes'):
        return 'y'
    elif response in ('n', 'no'):
        return 'n'
    elif response in ('a', 'all'):
        return 'a'
    elif response in ('q', 'quit'):
        return 'q'
    return None
```

Use `.casefold()` not `.lower()` for proper Unicode handling.
  </action>
  <verify>
Run: `python3 -c "from filematcher.cli import _normalize_response; print(_normalize_response('YES'), _normalize_response('no'), _normalize_response('invalid'))"`
Expected output: `y n None`
  </verify>
  <done>_normalize_response() function exists and correctly normalizes y/yes/n/no/a/all/q/quit to single chars</done>
</task>

<task type="auto">
  <name>Task 2: Add prompt_for_group function</name>
  <files>filematcher/cli.py</files>
  <action>
Add `prompt_for_group()` function after `_normalize_response()`:

```python
def prompt_for_group(
    formatter: ActionFormatter,
    group_index: int,
    total_groups: int,
    action: str
) -> str:
    """Prompt user for group decision, re-prompt on invalid input.

    Returns normalized single-char response: 'y', 'n', 'a', or 'q'.
    Raises: KeyboardInterrupt, EOFError (for caller to handle)
    """
    while True:
        prompt_text = formatter.format_group_prompt(group_index, total_groups, action)
        response = input(prompt_text).strip()

        normalized = _normalize_response(response)
        if normalized is not None:
            return normalized

        print("Invalid response. Please enter y (yes), n (no), a (all), or q (quit).")
```

Key behaviors:
- Uses `input()` builtin (strips newline automatically)
- Re-prompts on invalid input (empty string, random text)
- Lets KeyboardInterrupt/EOFError propagate for caller to handle
- Error message matches CONTEXT.md: "Please enter y (yes), n (no), a (all), or q (quit): "
  </action>
  <verify>
Manual verification: function defined and calls formatter.format_group_prompt()
Run: `python3 -c "from filematcher.cli import prompt_for_group; print('prompt_for_group defined')"`
  </verify>
  <done>prompt_for_group() prompts user, validates response, re-prompts on invalid, returns normalized char</done>
</task>

<task type="auto">
  <name>Task 3: Add interactive_execute function</name>
  <files>filematcher/cli.py</files>
  <action>
Add import for `execute_action` and `log_operation` from filematcher.actions at the top (update existing import line):

```python
from filematcher.actions import (
    create_audit_logger, write_log_header, log_operation, write_log_footer,
    execute_all_actions, execute_action, determine_exit_code,
)
from filematcher.types import FailedOperation
```

Then add `interactive_execute()` function after `prompt_for_group()`:

```python
def interactive_execute(
    groups: list[DuplicateGroup],
    action: Action,
    formatter: ActionFormatter,
    fallback_symlink: bool = False,
    audit_logger: logging.Logger | None = None,
    file_hashes: dict[str, str] | None = None,
    target_dir: str | None = None,
    dir2_base: str | None = None,
    verbose: bool = False,
    file_sizes_map: dict[str, dict[str, int]] | None = None,
    cross_fs_files: set[str] | None = None,
) -> tuple[int, int, int, int, list[FailedOperation], int, int]:
    """Execute with per-group interactive confirmation.

    Displays each group, prompts y/n/a/q, executes immediately on confirmation.

    Args:
        groups: List of DuplicateGroup tuples to process
        action: Action to execute (hardlink, symlink, delete)
        formatter: ActionFormatter for display/prompts
        fallback_symlink: Use symlink for cross-filesystem hardlinks
        audit_logger: Logger for audit trail
        file_hashes: Map of file path to hash
        target_dir: Target directory for links
        dir2_base: Base dir2 path for relative path computation
        verbose: Show verbose output
        file_sizes_map: Pre-computed file sizes keyed by master file
        cross_fs_files: Set of files on different filesystem

    Returns:
        Tuple of (success_count, failure_count, skipped_count, space_saved,
                  failed_list, confirmed_count, user_skipped_count)
    """
    success_count = 0
    failure_count = 0
    skipped_count = 0
    space_saved = 0
    failed_list: list[FailedOperation] = []
    confirmed_count = 0
    user_skipped_count = 0
    confirm_all = False

    total_groups = len(groups)

    try:
        for i, group in enumerate(groups, start=1):
            master_file, duplicates, reason, file_hash = group

            # Get pre-computed file sizes if available
            file_sizes = file_sizes_map.get(master_file) if file_sizes_map else None

            # Display the group
            formatter.format_duplicate_group(
                master_file,
                duplicates,
                action=action.value,
                file_hash=file_hash if verbose else None,
                file_sizes=file_sizes,
                cross_fs_files=cross_fs_files,
                group_index=i,
                total_groups=total_groups,
                target_dir=target_dir,
                dir2_base=dir2_base
            )

            if confirm_all:
                # Auto-confirm: show status, execute immediately
                formatter.format_confirmation_status(confirmed=True)
                # Execute this group - mirror execute_all_actions pattern
                for dup in duplicates:
                    # Get file size BEFORE action (for space_saved calculation)
                    file_size = os.path.getsize(dup) if os.path.exists(dup) else 0
                    dup_hash = file_hashes.get(dup, "unknown") if file_hashes else "unknown"

                    # Call execute_action with correct signature: (duplicate, master, action, ...)
                    success, error, actual_action = execute_action(
                        dup, master_file, action.value,
                        fallback_symlink=fallback_symlink,
                        target_dir=target_dir,
                        dir2_base=dir2_base
                    )

                    # Log operation if audit logger provided
                    if audit_logger:
                        log_operation(audit_logger, actual_action, dup, master_file,
                                      file_size, dup_hash, success, error)

                    # Track counts per execute_all_actions pattern
                    if actual_action == "skipped":
                        skipped_count += 1
                    elif success:
                        success_count += 1
                        space_saved += file_size
                    else:
                        failure_count += 1
                        failed_list.append(FailedOperation(dup, error))
                confirmed_count += 1
                continue

            # Prompt for decision
            response = prompt_for_group(formatter, i, total_groups, action.value)

            if response == 'y':
                formatter.format_confirmation_status(confirmed=True)
                # Execute this group - mirror execute_all_actions pattern
                for dup in duplicates:
                    # Get file size BEFORE action (for space_saved calculation)
                    file_size = os.path.getsize(dup) if os.path.exists(dup) else 0
                    dup_hash = file_hashes.get(dup, "unknown") if file_hashes else "unknown"

                    # Call execute_action with correct signature: (duplicate, master, action, ...)
                    success, error, actual_action = execute_action(
                        dup, master_file, action.value,
                        fallback_symlink=fallback_symlink,
                        target_dir=target_dir,
                        dir2_base=dir2_base
                    )

                    # Log operation if audit logger provided
                    if audit_logger:
                        log_operation(audit_logger, actual_action, dup, master_file,
                                      file_size, dup_hash, success, error)

                    # Track counts per execute_all_actions pattern
                    if actual_action == "skipped":
                        skipped_count += 1
                    elif success:
                        success_count += 1
                        space_saved += file_size
                    else:
                        failure_count += 1
                        failed_list.append(FailedOperation(dup, error))
                confirmed_count += 1

            elif response == 'n':
                formatter.format_confirmation_status(confirmed=False)
                user_skipped_count += 1

            elif response == 'a':
                formatter.format_confirmation_status(confirmed=True)
                remaining = total_groups - i
                if remaining > 0:
                    formatter.format_remaining_count(remaining)
                # Execute this group - mirror execute_all_actions pattern
                for dup in duplicates:
                    # Get file size BEFORE action (for space_saved calculation)
                    file_size = os.path.getsize(dup) if os.path.exists(dup) else 0
                    dup_hash = file_hashes.get(dup, "unknown") if file_hashes else "unknown"

                    # Call execute_action with correct signature: (duplicate, master, action, ...)
                    success, error, actual_action = execute_action(
                        dup, master_file, action.value,
                        fallback_symlink=fallback_symlink,
                        target_dir=target_dir,
                        dir2_base=dir2_base
                    )

                    # Log operation if audit logger provided
                    if audit_logger:
                        log_operation(audit_logger, actual_action, dup, master_file,
                                      file_size, dup_hash, success, error)

                    # Track counts per execute_all_actions pattern
                    if actual_action == "skipped":
                        skipped_count += 1
                    elif success:
                        success_count += 1
                        space_saved += file_size
                    else:
                        failure_count += 1
                        failed_list.append(FailedOperation(dup, error))
                confirmed_count += 1
                confirm_all = True

            elif response == 'q':
                break

    except (KeyboardInterrupt, EOFError):
        print()  # Newline after ^C

    return (success_count, failure_count, skipped_count, space_saved,
            failed_list, confirmed_count, user_skipped_count)
```

Key behaviors from CONTEXT.md:
- Execute immediately after each 'y' response (not batched)
- 'a' shows remaining count THEN sets confirm_all for subsequent groups
- 'q' breaks loop immediately
- KeyboardInterrupt/EOFError treated same as quit
- Returns extended tuple with confirmed_count and user_skipped_count for summary

**IMPORTANT: execute_action signature alignment**
The execute_action function signature is: `execute_action(duplicate, master, action, fallback_symlink, target_dir, dir2_base) -> tuple[bool, str, str]`
Returns `(success, error, actual_action)` - NOT a 5-tuple.

Pattern from execute_all_actions (actions.py lines 210-226):
1. Get `file_size = os.path.getsize(dup)` BEFORE calling execute_action
2. Call `success, error, actual_action = execute_action(dup, master_file, action.value, ...)`
3. If `audit_logger`: call `log_operation(audit_logger, actual_action, dup, master_file, file_size, file_hash, success, error)`
4. Track counts: `if actual_action == "skipped": skipped_count += 1; elif success: success_count += 1, space_saved += file_size; else: failure_count += 1, failed_list.append(FailedOperation(dup, error))`
  </action>
  <verify>
Run: `python3 -c "from filematcher.cli import interactive_execute; print('interactive_execute imported successfully')"`
Run: `python3 run_tests.py` - All 253 tests should still pass (no behavior change yet)
  </verify>
  <done>interactive_execute() function implements per-group loop with immediate execution on confirmation</done>
</task>

</tasks>

<verification>
After all tasks:
1. `python3 -c "from filematcher.cli import interactive_execute, prompt_for_group, _normalize_response; print('All functions importable')"` - succeeds
2. `python3 run_tests.py` - 253 tests pass (function exists but not yet wired into main)
3. Grep verification: `grep -n "def interactive_execute" filematcher/cli.py` shows function defined
4. Grep verification: `grep -n "format_group_prompt" filematcher/cli.py` shows formatter integration
</verification>

<success_criteria>
- Three new functions exist in cli.py: interactive_execute, prompt_for_group, _normalize_response
- Response normalization handles all 8 valid inputs (y/yes/n/no/a/all/q/quit) case-insensitively
- Interactive loop displays group -> prompts -> executes immediately on confirmation
- 'a' response shows remaining count and auto-confirms remaining
- 'q' response or Ctrl+C stops loop immediately
- All existing tests pass (no regression)
</success_criteria>

<output>
After completion, create `.planning/phases/19-interactive-core/19-01-SUMMARY.md`
</output>
