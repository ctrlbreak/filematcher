---
phase: 20-cli-integration
plan: 02
type: execute
wave: 2
depends_on: ["20-01"]
files_modified:
  - filematcher/cli.py
  - tests/test_safe_defaults.py
autonomous: true

must_haves:
  truths:
    - "--execute without --yes enters interactive mode (prompts for each group)"
    - "--execute --yes runs batch mode without prompts (existing behavior preserved)"
    - "Interactive mode shows banner BEFORE first group prompt"
    - "Banner appears in both interactive and batch execute modes"
    - "Exit codes: 0 success, 1 error, 2 partial failure (preserved)"
  artifacts:
    - path: "filematcher/cli.py"
      provides: "Mode routing logic in execute_mode block"
      contains: "interactive_execute"
    - path: "tests/test_safe_defaults.py"
      provides: "Integration tests for mode routing"
      contains: "TestModeRouting"
  key_links:
    - from: "filematcher/cli.py main()"
      to: "interactive_execute()"
      via: "mode routing when args.yes is False"
      pattern: "if not args\\.yes.*interactive_execute"
    - from: "filematcher/cli.py"
      to: "format_execute_banner()"
      via: "banner display before execution"
      pattern: "format_execute_banner.*print"
---

<objective>
Wire interactive mode into CLI with mode routing between interactive_execute() and batch execution based on --yes flag.

Purpose: Complete the CLI integration so users running `--execute` without `--yes` enter interactive mode with per-group prompts, while `--execute --yes` preserves existing batch behavior.
Output: Mode routing logic in cli.py main(), integration tests for routing behavior
</objective>

<execution_context>
@/Users/patrick/.claude/get-shit-done/workflows/execute-plan.md
@/Users/patrick/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/20-cli-integration/20-CONTEXT.md
@.planning/phases/20-cli-integration/20-RESEARCH.md
@.planning/phases/20-cli-integration/20-01-SUMMARY.md
@filematcher/cli.py
@filematcher/formatters.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add mode routing for interactive vs batch execution</name>
  <files>filematcher/cli.py</files>
  <action>
Modify the `execute_mode` block in main() (around line 607) to route between interactive and batch modes based on `args.yes`.

Current flow (batch only):
```
elif execute_mode:
    if args.json:
        # JSON batch execution
    else:
        # Text batch execution with single Y/N confirm
```

New flow:
```
elif execute_mode:
    if args.json:
        # JSON batch execution (unchanged - already requires --yes)
    else:
        # Add banner display for both modes
        space_info = calculate_space_savings(master_results)
        banner, separator = format_execute_banner(
            args.action.value,
            space_info.group_count,
            space_info.duplicate_count,
            space_info.bytes_saved,
            color_config
        )

        if not args.quiet:
            print(banner)
            print(separator)

        if args.yes:
            # Batch mode - existing flow (no single Y/N prompt needed with --yes)
            # Show preview, then execute
            ...
        else:
            # Interactive mode - use interactive_execute()
            file_hash_lookup = build_file_hash_lookup(matches)
            file_sizes_map = {}
            for master_file, duplicates, reason, file_hash in master_results:
                file_sizes_map[master_file] = build_file_sizes([master_file] + duplicates)

            cross_fs_to_show = get_cross_fs_for_hardlink(args.action, cross_fs_files)

            # Create audit logger
            log_path_obj = Path(args.log) if args.log else None
            audit_logger, actual_log_path = create_audit_logger(log_path_obj)

            base_flags = ['--execute']
            flags = build_log_flags(base_flags, verbose=args.verbose,
                                   fallback_symlink=args.fallback_symlink,
                                   log_path=args.log, target_dir=args.target_dir)
            write_log_header(audit_logger, args.dir1, args.dir2, args.dir1, args.action, flags)

            (success_count, failure_count, skipped_count, space_saved,
             failed_list, confirmed_count, user_skipped_count) = interactive_execute(
                groups=sorted(master_results, key=lambda x: x[0]),
                action=args.action,
                formatter=action_formatter,
                fallback_symlink=args.fallback_symlink,
                audit_logger=audit_logger,
                file_hashes=file_hash_lookup,
                target_dir=args.target_dir,
                dir2_base=args.dir2,
                verbose=args.verbose,
                file_sizes_map=file_sizes_map,
                cross_fs_files=cross_fs_to_show
            )

            write_log_footer(audit_logger, success_count, failure_count,
                           skipped_count, space_saved, failed_list)

            # Show execution summary
            action_formatter.format_execution_summary(
                success_count=success_count,
                failure_count=failure_count,
                skipped_count=skipped_count,
                space_saved=space_saved,
                log_path=str(actual_log_path),
                failed_list=failed_list
            )

            return determine_exit_code(success_count, failure_count)
```

Key points:
1. Import `format_execute_banner` from formatters at top of file
2. Banner displays BEFORE any group output or prompts
3. Interactive mode uses `interactive_execute()` from Phase 19
4. Batch mode (--yes) continues to use existing `execute_with_logging()`
5. Both modes show the banner (unless --quiet)

Remove the single Y/N confirmation prompt for batch mode when --yes is provided (it's redundant - --yes already means "skip confirmation").
  </action>
  <verify>
```bash
cd /Users/patrick/dev/cursor_projects/filematcher

# Test 1: Interactive mode (should prompt)
# Create temp dirs with duplicate files
mkdir -p /tmp/fm_test1 /tmp/fm_test2
echo "content" > /tmp/fm_test1/file.txt
echo "content" > /tmp/fm_test2/file.txt

# Run with --execute (no --yes) - should prompt
echo "n" | python -m filematcher /tmp/fm_test1 /tmp/fm_test2 --action delete --execute

# Test 2: Batch mode (should NOT prompt)
python -m filematcher /tmp/fm_test1 /tmp/fm_test2 --action hardlink --execute --yes

# Cleanup
rm -rf /tmp/fm_test1 /tmp/fm_test2
```
  </verify>
  <done>Interactive mode prompts for each group when --execute without --yes; batch mode runs without prompts when --execute --yes; banner appears before first prompt/execution</done>
</task>

<task type="auto">
  <name>Task 2: Add integration tests for mode routing</name>
  <files>tests/test_safe_defaults.py</files>
  <action>
Add a new test class `TestModeRouting` to test_safe_defaults.py to verify the mode routing behavior.

```python
class TestModeRouting(BaseFileMatcherTest):
    """Tests for interactive vs batch mode routing."""

    def test_execute_without_yes_prompts_interactively(self):
        """--execute without --yes should prompt for each group."""
        with patch('sys.argv', ['file_matcher.py', self.test_dir1, self.test_dir2,
                   '--action', 'delete', '--execute']):
            with patch('sys.stdin.isatty', return_value=True):
                # Respond 'n' to first prompt to skip
                with patch('builtins.input', return_value='n') as mock_input:
                    f = io.StringIO()
                    with redirect_stdout(f):
                        result = main()
                    # input() should be called for interactive prompt
                    self.assertTrue(mock_input.called)
                    # Should see the [y/n/a/q] prompt format (not old [y/N])
                    call_args = mock_input.call_args[0][0] if mock_input.call_args[0] else ""
                    self.assertIn("[y/n/a/q]", call_args)

    def test_execute_with_yes_no_prompts(self):
        """--execute --yes should not prompt (batch mode)."""
        with patch('sys.argv', ['file_matcher.py', self.test_dir1, self.test_dir2,
                   '--action', 'hardlink', '--execute', '--yes']):
            with patch('builtins.input') as mock_input:
                f = io.StringIO()
                with redirect_stdout(f):
                    main()
                # input() should NOT be called
                mock_input.assert_not_called()

    def test_execute_shows_banner_before_prompts(self):
        """Interactive mode should show banner before first prompt."""
        with patch('sys.argv', ['file_matcher.py', self.test_dir1, self.test_dir2,
                   '--action', 'delete', '--execute']):
            with patch('sys.stdin.isatty', return_value=True):
                with patch('builtins.input', return_value='q'):
                    f = io.StringIO()
                    with redirect_stdout(f):
                        main()
                    output = f.getvalue()
                    # Banner should contain action and stats
                    self.assertIn("delete", output.lower())
                    self.assertIn("groups", output.lower())
                    # 40-dash separator should appear
                    self.assertIn("-" * 40, output)

    def test_execute_batch_shows_banner(self):
        """Batch mode should also show banner."""
        with patch('sys.argv', ['file_matcher.py', self.test_dir1, self.test_dir2,
                   '--action', 'hardlink', '--execute', '--yes']):
            f = io.StringIO()
            with redirect_stdout(f):
                main()
            output = f.getvalue()
            # Banner should contain action and stats
            self.assertIn("hardlink", output.lower())
            self.assertIn("-" * 40, output)

    def test_execute_interactive_q_exits_cleanly(self):
        """Pressing 'q' in interactive mode should exit cleanly."""
        with patch('sys.argv', ['file_matcher.py', self.test_dir1, self.test_dir2,
                   '--action', 'delete', '--execute']):
            with patch('sys.stdin.isatty', return_value=True):
                with patch('builtins.input', return_value='q'):
                    f = io.StringIO()
                    with redirect_stdout(f):
                        result = main()
                    # Should exit with 0 (clean exit)
                    self.assertEqual(result, 0)

    def test_execute_interactive_a_confirms_all(self):
        """Pressing 'a' should confirm current and all remaining groups."""
        with patch('sys.argv', ['file_matcher.py', self.test_dir1, self.test_dir2,
                   '--action', 'hardlink', '--execute']):
            with patch('sys.stdin.isatty', return_value=True):
                # First prompt: 'a' to confirm all
                with patch('builtins.input', return_value='a') as mock_input:
                    f = io.StringIO()
                    with redirect_stdout(f):
                        main()
                    # Should only be called once (then auto-confirms rest)
                    self.assertEqual(mock_input.call_count, 1)
```
  </action>
  <verify>
```bash
cd /Users/patrick/dev/cursor_projects/filematcher
python3 -m unittest tests.test_safe_defaults.TestModeRouting -v
```
All 6 tests should pass.
  </verify>
  <done>TestModeRouting class exists with 6 tests covering interactive prompting, batch mode, banner display, 'q' exit, and 'a' confirm-all behavior, all tests pass</done>
</task>

<task type="auto">
  <name>Task 3: Verify full test suite and integration</name>
  <files>tests/test_safe_defaults.py</files>
  <action>
Run the complete test suite to verify:
1. All existing tests still pass (no regressions)
2. All new tests pass
3. Interactive mode works end-to-end

Also verify the specific requirements from CONTEXT.md:
- Banner format matches: "{bold action} mode: X groups, Y files, Z to save"
- 40-character separator after banner
- Flag validation errors use parser.error() with exit code 2

If any tests fail, fix the underlying implementation issues.
  </action>
  <verify>
```bash
cd /Users/patrick/dev/cursor_projects/filematcher

# Full test suite
python3 run_tests.py

# Specific module tests
python3 -m unittest tests.test_safe_defaults -v
python3 -m unittest tests.test_interactive -v

# Manual verification of banner format
mkdir -p /tmp/fm_test1 /tmp/fm_test2
echo "test content here" > /tmp/fm_test1/file.txt
echo "test content here" > /tmp/fm_test2/file.txt
echo "q" | python -m filematcher /tmp/fm_test1 /tmp/fm_test2 --action delete --execute 2>&1 | head -20
rm -rf /tmp/fm_test1 /tmp/fm_test2
```
  </verify>
  <done>Full test suite passes (273 base + 11 new = 284 tests), banner displays correctly with format and separator, all requirements verified</done>
</task>

</tasks>

<verification>
Complete verification checklist:

1. **Mode routing:**
```bash
# Interactive mode (responds to input)
echo "n" | python -m filematcher test_dir1 test_dir2 --action delete --execute
# Should show [y/n/a/q] prompt

# Batch mode (no prompts)
python -m filematcher test_dir1 test_dir2 --action hardlink --execute --yes
# Should execute without any prompts
```

2. **Banner display:**
```bash
# Both modes should show banner
echo "q" | python -m filematcher test_dir1 test_dir2 --action delete --execute 2>&1 | grep -E "delete mode:|^-{40}$"
```

3. **Exit codes:**
```bash
# Success
python -m filematcher test_dir1 test_dir2 --action hardlink --execute --yes; echo "Exit: $?"
# Partial failure
python -m filematcher /nonexistent /tmp --action hardlink --execute --yes 2>&1; echo "Exit: $?"
```

4. **Full test suite:**
```bash
python3 run_tests.py
```
</verification>

<success_criteria>
1. `--execute` without `--yes` enters interactive mode with per-group [y/n/a/q] prompts
2. `--execute --yes` runs batch mode without any prompts
3. Banner appears BEFORE first prompt in interactive mode
4. Banner appears in batch mode too
5. 'q' response exits cleanly with code 0
6. 'a' response confirms all remaining groups
7. Existing batch behavior preserved (exit codes, logging, etc.)
8. All 284 tests pass (273 existing + 11 new)
</success_criteria>

<output>
After completion, create `.planning/phases/20-cli-integration/20-02-SUMMARY.md`
</output>
