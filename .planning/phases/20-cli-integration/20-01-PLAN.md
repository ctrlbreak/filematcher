---
phase: 20-cli-integration
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - filematcher/cli.py
  - filematcher/formatters.py
autonomous: true

must_haves:
  truths:
    - "--json --execute without --yes produces error with exit code 2"
    - "--quiet --execute without --yes produces error with exit code 2"
    - "Non-TTY stdin with --execute (no --yes) produces error with exit code 2"
    - "Validation errors occur BEFORE find_matching_files runs"
    - "format_execute_banner returns formatted string with bold action and stats"
  artifacts:
    - path: "filematcher/cli.py"
      provides: "Flag validation block near line 409"
      contains: "parser.error"
    - path: "filematcher/formatters.py"
      provides: "format_execute_banner function"
      exports: ["format_execute_banner"]
  key_links:
    - from: "filematcher/cli.py"
      to: "parser.error()"
      via: "flag conflict validation"
      pattern: "parser\\.error.*--json|parser\\.error.*--quiet|parser\\.error.*isatty"
---

<objective>
Add fail-fast flag validation and banner formatting for interactive execute mode.

Purpose: Ensure invalid flag combinations fail immediately with clear error messages (before expensive file scanning), and provide the banner display function for interactive/batch execute modes.
Output: Flag validation block in cli.py, format_execute_banner function in formatters.py
</objective>

<execution_context>
@/Users/patrick/.claude/get-shit-done/workflows/execute-plan.md
@/Users/patrick/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/20-cli-integration/20-CONTEXT.md
@.planning/phases/20-cli-integration/20-RESEARCH.md
@filematcher/cli.py
@filematcher/formatters.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add fail-fast flag validation block</name>
  <files>filematcher/cli.py</files>
  <action>
Add flag validation checks IMMEDIATELY after `args = parser.parse_args()` and BEFORE `find_matching_files()` is called. Place these checks in the existing validation block (around line 409-421).

Add three new validations:

1. **Non-TTY check** (only when --execute without --yes):
```python
if args.execute and not args.yes and args.action != Action.COMPARE:
    if not sys.stdin.isatty():
        parser.error("stdin is not a terminal")
```

2. **--quiet + --execute without --yes**:
```python
if args.quiet and args.execute and not args.yes:
    parser.error("--quiet and interactive mode are incompatible")
```

3. **Verify existing --json check** already covers the case (it does at line 409-410).

Error message format (per CONTEXT.md):
- Use parser.error() for consistent exit code 2
- Focus on the conflict, not the resolution
- Do NOT suggest --yes in the error message

Place these checks AFTER the existing validation block but BEFORE the `master_path = Path(args.dir1).resolve()` line to ensure fail-fast before any filesystem operations.
  </action>
  <verify>
Run these commands and verify exit code 2 and error messages:
```bash
cd /Users/patrick/dev/cursor_projects/filematcher
# Non-TTY check
echo "" | python -m filematcher test_dir1 test_dir2 --action delete --execute 2>&1; echo "Exit: $?"
# --quiet + --execute
python -m filematcher test_dir1 test_dir2 --action delete --execute --quiet 2>&1; echo "Exit: $?"
# --json + --execute (existing)
python -m filematcher test_dir1 test_dir2 --action delete --execute --json 2>&1; echo "Exit: $?"
```
  </verify>
  <done>All three invalid flag combinations produce parser.error() with exit code 2 and appropriate error messages, validated BEFORE find_matching_files runs</done>
</task>

<task type="auto">
  <name>Task 2: Add format_execute_banner function</name>
  <files>filematcher/formatters.py</files>
  <action>
Add a new function `format_execute_banner()` to formatters.py that creates the banner line per CONTEXT.md specification.

Banner format: `{bold action} mode: X groups, Y files, Z to save`
Followed by: 40-character dashed separator

Implementation:
```python
from filematcher.colors import bold

EXECUTE_BANNER_SEPARATOR = "-" * 40

def format_execute_banner(
    action: str,
    group_count: int,
    duplicate_count: int,
    space_bytes: int,
    color_config: ColorConfig | None = None
) -> tuple[str, str]:
    """Format execute mode banner with statistics.

    Args:
        action: Action type (hardlink, symlink, delete)
        group_count: Number of duplicate groups
        duplicate_count: Total number of duplicate files
        space_bytes: Space in bytes to be saved
        color_config: Color configuration for bold formatting

    Returns:
        Tuple of (banner_line, separator_line)
    """
    cc = color_config or ColorConfig(mode=ColorMode.NEVER)
    action_bold = bold(action, cc)
    space_str = format_file_size(space_bytes)
    banner = f"{action_bold} mode: {group_count} groups, {duplicate_count} files, {space_str} to save"
    return (banner, EXECUTE_BANNER_SEPARATOR)
```

Also add `bold` to the imports from filematcher.colors if not already present.

Export the function by ensuring it's available at module level.
  </action>
  <verify>
```python
# Quick verification in Python REPL
from filematcher.formatters import format_execute_banner
from filematcher.colors import ColorConfig, ColorMode
banner, sep = format_execute_banner("hardlink", 15, 47, 1200000000)
print(banner)  # Should show: hardlink mode: 15 groups, 47 files, 1.1 GB to save
print(sep)     # Should show: ----------------------------------------
print(len(sep) == 40)  # Should be True
```
  </verify>
  <done>format_execute_banner function exists, returns tuple of (banner_line, separator), banner includes bold action and stats, separator is 40 dashes</done>
</task>

<task type="auto">
  <name>Task 3: Add unit tests for flag validation</name>
  <files>tests/test_safe_defaults.py</files>
  <action>
Add a new test class `TestInteractiveFlagValidation` to test_safe_defaults.py with tests for the new flag validation cases.

```python
class TestInteractiveFlagValidation(BaseFileMatcherTest):
    """Tests for interactive mode flag validation."""

    def test_quiet_execute_without_yes_fails(self):
        """--quiet --execute without --yes should fail."""
        stderr_capture = io.StringIO()
        with patch('sys.argv', ['file_matcher.py', self.test_dir1, self.test_dir2,
                   '--action', 'delete', '--execute', '--quiet']):
            with redirect_stderr(stderr_capture):
                with self.assertRaises(SystemExit) as cm:
                    main()
            self.assertEqual(cm.exception.code, 2)
        error_output = stderr_capture.getvalue()
        self.assertIn("--quiet", error_output)
        self.assertIn("interactive", error_output.lower())

    def test_quiet_execute_with_yes_succeeds(self):
        """--quiet --execute --yes should work (batch mode)."""
        with patch('sys.argv', ['file_matcher.py', self.test_dir1, self.test_dir2,
                   '--action', 'hardlink', '--execute', '--quiet', '--yes']):
            f = io.StringIO()
            with redirect_stdout(f):
                result = main()
            # Should succeed (may have 0 or partial success depending on test files)
            self.assertIn(result, [0, 2])  # 0 success, 2 partial

    def test_non_tty_execute_without_yes_fails(self):
        """Non-TTY stdin with --execute (no --yes) should fail early."""
        stderr_capture = io.StringIO()
        with patch('sys.argv', ['file_matcher.py', self.test_dir1, self.test_dir2,
                   '--action', 'delete', '--execute']):
            with patch('sys.stdin.isatty', return_value=False):
                with redirect_stderr(stderr_capture):
                    with self.assertRaises(SystemExit) as cm:
                        main()
                self.assertEqual(cm.exception.code, 2)
        error_output = stderr_capture.getvalue()
        self.assertIn("stdin", error_output.lower())
        self.assertIn("terminal", error_output.lower())

    def test_json_execute_without_yes_fails(self):
        """--json --execute without --yes should fail (existing behavior)."""
        stderr_capture = io.StringIO()
        with patch('sys.argv', ['file_matcher.py', self.test_dir1, self.test_dir2,
                   '--action', 'delete', '--execute', '--json']):
            with redirect_stderr(stderr_capture):
                with self.assertRaises(SystemExit) as cm:
                    main()
            self.assertEqual(cm.exception.code, 2)
        error_output = stderr_capture.getvalue()
        self.assertIn("--json", error_output)

    def test_json_execute_with_yes_succeeds(self):
        """--json --execute --yes should work."""
        with patch('sys.argv', ['file_matcher.py', self.test_dir1, self.test_dir2,
                   '--action', 'hardlink', '--execute', '--json', '--yes']):
            f = io.StringIO()
            with redirect_stdout(f):
                result = main()
            output = f.getvalue()
            # Should produce valid JSON
            import json
            data = json.loads(output)
            self.assertIn("execution", data)
```

Ensure imports are present at top of file:
- `from contextlib import redirect_stderr` (if not present)
  </action>
  <verify>
```bash
cd /Users/patrick/dev/cursor_projects/filematcher
python3 -m unittest tests.test_safe_defaults.TestInteractiveFlagValidation -v
```
All 5 tests should pass.
  </verify>
  <done>TestInteractiveFlagValidation class exists with 5 tests covering --quiet+execute, non-TTY, and --json+execute validation cases, all tests pass</done>
</task>

</tasks>

<verification>
Run full test suite to ensure no regressions:
```bash
cd /Users/patrick/dev/cursor_projects/filematcher
python3 run_tests.py
```
All tests pass (273 + 5 new = 278 tests).

Manual verification of fail-fast behavior:
```bash
# This should fail IMMEDIATELY without processing files
time (echo "" | python -m filematcher /tmp /tmp --action delete --execute 2>&1)
# Should complete in <1 second (not scanning /tmp)
```
</verification>

<success_criteria>
1. `--json --execute` without `--yes` exits with code 2 and error message
2. `--quiet --execute` without `--yes` exits with code 2 and error message
3. Non-TTY `--execute` without `--yes` exits with code 2 and error message
4. All validations happen BEFORE find_matching_files (fail-fast)
5. format_execute_banner returns properly formatted banner with 40-char separator
6. All 278 tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/20-cli-integration/20-01-SUMMARY.md`
</output>
