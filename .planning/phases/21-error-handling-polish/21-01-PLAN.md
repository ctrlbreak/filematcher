---
phase: 21-error-handling-polish
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - filematcher/formatters.py
  - filematcher/cli.py
  - filematcher/actions.py
autonomous: true

must_haves:
  truths:
    - "Permission errors on individual files display inline and execution continues"
    - "User sees system error message (e.g., 'Permission denied') for each failed file"
    - "'q' response shows clean partial summary with files processed and remaining"
    - "Exit code 130 returned when user quits via 'q' or Ctrl+C"
    - "Audit log creation failure aborts with exit code 2 before any file operations"
  artifacts:
    - path: "filematcher/formatters.py"
      provides: "format_file_error() and format_quit_summary() methods"
      contains: "def format_file_error"
    - path: "filematcher/cli.py"
      provides: "Error handling in interactive_execute and quit summary display"
      contains: "EXIT_USER_QUIT"
    - path: "filematcher/actions.py"
      provides: "Fail-fast audit logger creation"
      contains: "sys.exit(2)"
  key_links:
    - from: "filematcher/cli.py"
      to: "filematcher/formatters.py"
      via: "formatter.format_file_error() calls in interactive_execute"
      pattern: "format_file_error"
    - from: "filematcher/cli.py"
      to: "filematcher/formatters.py"
      via: "formatter.format_quit_summary() call on 'q' response"
      pattern: "format_quit_summary"
---

<objective>
Add inline error display for file operation failures and clean quit summary when user cancels.

Purpose: ERR-01 (permission errors skip and continue) and ERR-02 (clean summary on cancellation) from v1.5 requirements.
Output: Updated formatters with error display methods, updated cli.py with error handling, audit logger fail-fast.
</objective>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/21-error-handling-polish/21-CONTEXT.md
@.planning/phases/21-error-handling-polish/21-RESEARCH.md
@filematcher/formatters.py
@filematcher/cli.py
@filematcher/actions.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add error display and quit summary methods to formatters</name>
  <files>filematcher/formatters.py</files>
  <action>
Add two new abstract methods to ActionFormatter ABC:

1. `format_file_error(self, file_path: str, error: str) -> None`:
   - Output error message for a failed file operation
   - Args: file_path (path that failed), error (system error message like "Permission denied")

2. `format_quit_summary(self, confirmed_count: int, skipped_count: int, remaining_count: int, space_saved: int, log_path: str) -> None`:
   - Display summary when user quits early via 'q' or Ctrl+C
   - Args: counts for processed/skipped/remaining, space_saved bytes, log_path for audit trail

Implement in TextActionFormatter:
- `format_file_error`: Print indented line with red X marker: `  {red(X)} {file_path}: {error}`
- `format_quit_summary`: Print quit message block:
  - Blank line
  - "Quit: {confirmed_count} processed, {skipped_count} skipped, {remaining_count} remaining"
  - If space_saved > 0: "Freed {format_file_size(space_saved)} (quit before completing all)"
  - "Re-run command to process remaining files"
  - "Audit log: {log_path}"

Implement in JsonActionFormatter:
- `format_file_error`: Accumulate error in self._data["errors"] array as {"path": file_path, "error": error}. Initialize "errors" key if not present.
- `format_quit_summary`: Add quit status to self._data with processed/skipped/remaining counts (JSON captures state for scripting even on early exit)

Also update JsonActionFormatter.finalize() to include "errors" array in output if present (for both normal and quit scenarios).
  </action>
  <verify>
Run: `python3 -c "from filematcher.formatters import TextActionFormatter, JsonActionFormatter, ActionFormatter; import inspect; assert 'format_file_error' in [m[0] for m in inspect.getmembers(ActionFormatter, predicate=inspect.isfunction)]"`
Should pass without error (method exists on ABC).
  </verify>
  <done>
ActionFormatter ABC has format_file_error() and format_quit_summary() abstract methods. TextActionFormatter displays red X with error. JsonActionFormatter accumulates errors in array.
  </done>
</task>

<task type="auto">
  <name>Task 2: Wire error handling into interactive_execute and handle quit</name>
  <files>filematcher/cli.py</files>
  <action>
Add exit code constants at module level (after imports):
```python
EXIT_SUCCESS = 0
EXIT_ERROR = 1
EXIT_PARTIAL = 2
EXIT_USER_QUIT = 130  # 128 + SIGINT (Unix convention)
```

Modify interactive_execute() to:

1. Catch OSError when getting file size before execute_action:
```python
try:
    file_size = os.path.getsize(dup) if os.path.exists(dup) else 0
except OSError as e:
    formatter.format_file_error(dup, str(e))
    failure_count += 1
    failed_list.append(FailedOperation(dup, str(e)))
    continue
```

2. After execute_action returns with success=False, call formatter.format_file_error(dup, error)

3. Track remaining_count on 'q' response and pass to caller:
   - Add user_quit: bool to return tuple (8th element)
   - When response == 'q':
     - Calculate remaining = total_groups - i (groups not yet processed)
     - Store this in a variable to return

4. Update return signature to include remaining_count and user_quit:
   `tuple[int, int, int, int, list[FailedOperation], int, int, int, bool]`
   (success, failure, skipped, space_saved, failed_list, confirmed, user_skipped, remaining, user_quit)

5. Update (KeyboardInterrupt, EOFError) handler to also set user_quit=True and calculate remaining

Update main() to handle quit:

1. After interactive_execute returns, check user_quit flag
2. If user_quit:
   - Call formatter.format_quit_summary(confirmed_count, user_skipped_count, remaining_count, space_saved, str(actual_log_path))
   - Return EXIT_USER_QUIT (130)
3. Otherwise continue with normal summary

NOTE: The existing code has duplicate execution blocks for 'y', 'a', and confirm_all cases. Each block needs the OSError handling added. Consider extracting a helper function `_execute_group_duplicates()` to avoid repetition, but keep changes minimal - just add try/except around file_size fetch and format_file_error after failed execute_action.
  </action>
  <verify>
Run: `python3 -c "from filematcher.cli import EXIT_USER_QUIT, EXIT_PARTIAL; assert EXIT_USER_QUIT == 130; assert EXIT_PARTIAL == 2"`
Should pass without error (constants defined correctly).
  </verify>
  <done>
interactive_execute catches OSError and displays inline errors. 'q' response returns remaining count. main() shows quit summary and returns exit 130. Execution continues after individual file errors.
  </done>
</task>

<task type="auto">
  <name>Task 3: Add fail-fast audit logger creation</name>
  <files>filematcher/actions.py</files>
  <action>
Modify create_audit_logger() to fail-fast if log file cannot be created:

1. After determining log_path but before creating the FileHandler:
```python
try:
    file_handler = logging.FileHandler(log_path, encoding='utf-8')
except OSError as e:
    # Audit trail is required for destructive operations
    print(f"Error: Cannot create audit log '{log_path}': {e}", file=sys.stderr)
    print("Audit trail is required for destructive operations. Aborting.", file=sys.stderr)
    sys.exit(2)
```

This ensures:
- If the log directory doesn't exist or isn't writable, we abort BEFORE any file operations
- Exit code 2 (per CONTEXT.md - partial/validation error)
- Clear error message explaining why

The current code doesn't handle FileHandler exceptions - it would raise an unhandled exception. This makes the failure explicit and user-friendly.
  </action>
  <verify>
Run: `python3 -c "import tempfile, os; os.makedirs('/tmp/test_fm_readonly', exist_ok=True); os.chmod('/tmp/test_fm_readonly', 0o444)"`
Then test manually: Creating a log in a read-only directory should print error and exit 2.
Cleanup: `os.chmod('/tmp/test_fm_readonly', 0o755); os.rmdir('/tmp/test_fm_readonly')`
  </verify>
  <done>
create_audit_logger() catches OSError when creating FileHandler, prints clear error message to stderr, and exits with code 2. No file operations occur if audit log cannot be created.
  </done>
</task>

</tasks>

<verification>
1. Run test suite: `python3 run_tests.py` - all existing tests pass
2. Import check: `python3 -c "from filematcher.formatters import ActionFormatter; from filematcher.cli import EXIT_USER_QUIT"` - no errors
3. Manual test: Create read-only directory, attempt to run with --log pointing there, verify exit 2
</verification>

<success_criteria>
- [ ] format_file_error() method exists on ActionFormatter ABC and both implementations
- [ ] format_quit_summary() method exists on ActionFormatter ABC and both implementations
- [ ] interactive_execute() catches OSError on file size fetch and calls format_file_error()
- [ ] interactive_execute() calls format_file_error() after failed execute_action()
- [ ] 'q' response triggers quit summary and returns EXIT_USER_QUIT (130)
- [ ] Ctrl+C/EOFError triggers quit summary and returns EXIT_USER_QUIT (130)
- [ ] create_audit_logger() exits with code 2 if log file cannot be created
- [ ] All existing tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/21-error-handling-polish/21-01-SUMMARY.md`
</output>
