---
phase: 21-error-handling-polish
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - filematcher/formatters.py
  - filematcher/cli.py
  - filematcher/actions.py
autonomous: true

must_haves:
  truths:
    - "Permission errors on individual files display inline and execution continues"
    - "User sees system error message (e.g., 'Permission denied') for each failed file"
    - "'q' response shows clean partial summary with files processed and remaining"
    - "Exit code 130 returned when user quits via 'q' or Ctrl+C"
    - "When audit log cannot be created, user sees error message and no files are modified"
  artifacts:
    - path: "filematcher/formatters.py"
      provides: "format_file_error() and format_quit_summary() methods"
      contains: "def format_file_error"
    - path: "filematcher/cli.py"
      provides: "Error handling in interactive_execute and quit summary display"
      contains: "EXIT_USER_QUIT"
    - path: "filematcher/actions.py"
      provides: "Fail-fast audit logger creation"
      contains: "sys.exit(2)"
  key_links:
    - from: "filematcher/cli.py"
      to: "filematcher/formatters.py"
      via: "formatter.format_file_error() calls in interactive_execute"
      pattern: "format_file_error"
    - from: "filematcher/cli.py"
      to: "filematcher/formatters.py"
      via: "formatter.format_quit_summary() call on 'q' response"
      pattern: "format_quit_summary"
---

<objective>
Add inline error display for file operation failures and clean quit summary when user cancels.

Purpose: ERR-01 (permission errors skip and continue) and ERR-02 (clean summary on cancellation) from v1.5 requirements.
Output: Updated formatters with error display methods, updated cli.py with error handling, audit logger fail-fast.
</objective>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/21-error-handling-polish/21-CONTEXT.md
@.planning/phases/21-error-handling-polish/21-RESEARCH.md
@filematcher/formatters.py
@filematcher/cli.py
@filematcher/actions.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add error display and quit summary methods to formatters</name>
  <files>filematcher/formatters.py</files>
  <action>
Add two new abstract methods to ActionFormatter ABC:

1. `format_file_error(self, file_path: str, error: str) -> None`:
   - Output error message for a failed file operation
   - Args: file_path (path that failed), error (system error message like "Permission denied")

2. `format_quit_summary(self, confirmed_count: int, skipped_count: int, remaining_count: int, space_saved: int, log_path: str) -> None`:
   - Display summary when user quits early via 'q' or Ctrl+C
   - Args: counts for processed/skipped/remaining, space_saved bytes, log_path for audit trail

Implement in TextActionFormatter:
- `format_file_error`: Print indented line with red X marker: `  {red(X)} {file_path}: {error}`
- `format_quit_summary`: Print quit message block:
  - Blank line
  - "Quit: {confirmed_count} processed, {skipped_count} skipped, {remaining_count} remaining"
  - If space_saved > 0: "Freed {format_file_size(space_saved)} (quit before completing all)"
  - "Re-run command to process remaining files"
  - "Audit log: {log_path}"

Implement in JsonActionFormatter:
- `format_file_error`: Accumulate error in self._data["errors"] array as {"path": file_path, "error": error}. Initialize "errors" key if not present.
- `format_quit_summary`: Add quit status to self._data with processed/skipped/remaining counts (JSON captures state for scripting even on early exit)

Also update JsonActionFormatter.finalize() to include "errors" array in output if present (for both normal and quit scenarios).
  </action>
  <verify>
Run: `python3 -c "from filematcher.formatters import TextActionFormatter, JsonActionFormatter, ActionFormatter; import inspect; assert 'format_file_error' in [m[0] for m in inspect.getmembers(ActionFormatter, predicate=inspect.isfunction)]"`
Should pass without error (method exists on ABC).
  </verify>
  <done>
ActionFormatter ABC has format_file_error() and format_quit_summary() abstract methods. TextActionFormatter displays red X with error. JsonActionFormatter accumulates errors in array.
  </done>
</task>

<task type="auto">
  <name>Task 2: Wire error handling into interactive_execute and handle quit</name>
  <files>filematcher/cli.py</files>
  <action>
Add exit code constants at module level (after imports):
```python
EXIT_SUCCESS = 0
EXIT_ERROR = 1
EXIT_PARTIAL = 2
EXIT_USER_QUIT = 130  # 128 + SIGINT (Unix convention)
```

Modify interactive_execute() return signature from current 7-element tuple to 9-element tuple:
```python
) -> tuple[int, int, int, int, list[FailedOperation], int, int, int, bool]:
    # Returns: (success_count, failure_count, skipped_count, space_saved, failed_list,
    #           confirmed_count, user_skipped_count, remaining_count, user_quit)
```

Update interactive_execute() to handle errors and quit in THREE duplicate execution blocks:

Block 1 - confirm_all branch (lines ~139-165):
Block 2 - 'y' response (lines ~174-202):
Block 3 - 'a' response (lines ~214-242):

Each block needs IDENTICAL changes:

1. Wrap file_size fetch in try/except OSError:
```python
try:
    file_size = os.path.getsize(dup) if os.path.exists(dup) else 0
except OSError as e:
    formatter.format_file_error(dup, str(e))
    # Still log to audit trail for failed operations
    log_operation(audit_logger, action, dup, master, success=False, error=str(e))
    failure_count += 1
    failed_list.append(FailedOperation(dup, str(e)))
    continue
```

2. After execute_action returns with success=False, call formatter.format_file_error(dup, error):
```python
success, error = execute_action(...)
if success:
    # existing success logic
else:
    formatter.format_file_error(dup, error)
    # existing failure logic (log_operation, failure_count++, etc.)
```

3. Track remaining_count on 'q' response:
   - When response == 'q':
     - Calculate remaining = len(duplicate_groups) - i - 1 (groups not yet started)
     - Set user_quit = True
     - Break out of loop

4. Update (KeyboardInterrupt, EOFError) handler to also:
   - Set user_quit = True
   - Calculate remaining_count from current loop position

5. Initialize at function start:
   - remaining_count = 0
   - user_quit = False

6. Return all 9 elements:
   - return (success_count, failure_count, skipped_count, space_saved, failed_list,
             confirmed_count, user_skipped_count, remaining_count, user_quit)

Update main() to handle quit:

1. Unpack all 9 return values from interactive_execute
2. Check user_quit flag after interactive_execute returns
3. If user_quit:
   - Call formatter.format_quit_summary(confirmed_count, user_skipped_count, remaining_count, space_saved, str(actual_log_path))
   - Return EXIT_USER_QUIT (130)
4. Otherwise continue with normal summary via format_execution_summary
  </action>
  <verify>
Run these commands to verify implementation:
1. `python3 -c "from filematcher.cli import EXIT_USER_QUIT, EXIT_PARTIAL; assert EXIT_USER_QUIT == 130; assert EXIT_PARTIAL == 2"` - constants defined
2. `grep -n "except OSError" filematcher/cli.py | wc -l` - should show 3 (one per execution block)
3. `grep -n "format_file_error" filematcher/cli.py | wc -l` - should show 6 (OSError + failed execute_action, times 3 blocks)
Should pass without error.
  </verify>
  <done>
interactive_execute catches OSError on file size fetch in all three execution blocks and calls format_file_error. Failed operations still logged to audit trail. 'q' response returns remaining count. main() shows quit summary and returns exit 130. Return tuple now has 9 elements: (success, failure, skipped, space_saved, failed_list, confirmed, user_skipped, remaining, user_quit).
  </done>
</task>

<task type="auto">
  <name>Task 3: Add fail-fast audit logger creation</name>
  <files>filematcher/actions.py</files>
  <action>
Modify create_audit_logger() to fail-fast if log file cannot be created:

1. After determining log_path but before creating the FileHandler:
```python
try:
    file_handler = logging.FileHandler(log_path, encoding='utf-8')
except OSError as e:
    # Audit trail is required for destructive operations
    print(f"Error: Cannot create audit log '{log_path}': {e}", file=sys.stderr)
    print("Audit trail is required for destructive operations. Aborting.", file=sys.stderr)
    sys.exit(2)
```

This ensures:
- If the log directory doesn't exist or isn't writable, we abort BEFORE any file operations
- Exit code 2 (per CONTEXT.md - partial/validation error)
- Clear error message explaining why

The current code doesn't handle FileHandler exceptions - it would raise an unhandled exception. This makes the failure explicit and user-friendly.
  </action>
  <verify>
Run: `python3 -c "import tempfile, os; os.makedirs('/tmp/test_fm_readonly', exist_ok=True); os.chmod('/tmp/test_fm_readonly', 0o444)"`
Then test manually: Creating a log in a read-only directory should print error and exit 2.
Cleanup: `os.chmod('/tmp/test_fm_readonly', 0o755); os.rmdir('/tmp/test_fm_readonly')`
  </verify>
  <done>
create_audit_logger() catches OSError when creating FileHandler, prints clear error message to stderr, and exits with code 2. No file operations occur if audit log cannot be created.
  </done>
</task>

</tasks>

<verification>
1. Run test suite: `python3 run_tests.py` - all existing tests pass
2. Import check: `python3 -c "from filematcher.formatters import ActionFormatter; from filematcher.cli import EXIT_USER_QUIT"` - no errors
3. Verify OSError handling: `grep -c "except OSError" filematcher/cli.py` - should be 3
4. Manual test: Create read-only directory, attempt to run with --log pointing there, verify exit 2
</verification>

<success_criteria>
- [ ] format_file_error() method exists on ActionFormatter ABC and both implementations
- [ ] format_quit_summary() method exists on ActionFormatter ABC and both implementations
- [ ] interactive_execute() catches OSError on file size fetch in all 3 execution blocks
- [ ] interactive_execute() calls format_file_error() after failed execute_action() in all 3 blocks
- [ ] OSError failures still call log_operation() for audit trail
- [ ] 'q' response triggers quit summary and returns EXIT_USER_QUIT (130)
- [ ] Ctrl+C/EOFError triggers quit summary and returns EXIT_USER_QUIT (130)
- [ ] Return tuple has 9 elements including remaining_count and user_quit
- [ ] create_audit_logger() exits with code 2 if log file cannot be created
- [ ] All existing tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/21-error-handling-polish/21-01-SUMMARY.md`
</output>
