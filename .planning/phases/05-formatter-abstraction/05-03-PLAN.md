---
phase: 05-formatter-abstraction
plan: 03
type: execute
wave: 2
depends_on: ["05-01"]
files_modified:
  - file_matcher.py
autonomous: true

must_haves:
  truths:
    - "Compare mode output routes through TextCompareFormatter"
    - "Output is byte-identical to current implementation"
    - "All existing tests pass without modification"
    - "Both master mode and non-master mode use formatter"
  artifacts:
    - path: "file_matcher.py"
      provides: "Wired compare formatter in main()"
      contains: "TextCompareFormatter("
  key_links:
    - from: "main() compare mode branches"
      to: "TextCompareFormatter"
      via: "formatter instantiation and method calls"
      pattern: "formatter\\.format_(match_group|summary|unmatched)"
---

<objective>
Wire TextCompareFormatter into main() to handle all compare mode output (no action specified), ensuring byte-identical output.

Purpose: Replace direct print() calls in compare mode with formatter method calls. Compare mode has two sub-modes: master mode (--action was NOT specified but we have master directory logic) and original mode (basic hash comparison).

Output: main() compare mode uses TextCompareFormatter, all tests still passing.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/05-formatter-abstraction/05-CONTEXT.md
@.planning/phases/05-formatter-abstraction/05-RESEARCH.md
@.planning/phases/05-formatter-abstraction/05-01-SUMMARY.md
@file_matcher.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Extend TextCompareFormatter for directory names</name>
  <files>file_matcher.py</files>
  <action>
The current TextCompareFormatter uses hardcoded "dir1"/"dir2" labels. Update it to accept directory names:

1. Update TextCompareFormatter.__init__ to accept and store directory names:
```python
class TextCompareFormatter(CompareFormatter):
    """Text output formatter for compare mode (no action specified)."""

    def __init__(self, verbose: bool = False, dir1_name: str = "dir1", dir2_name: str = "dir2"):
        super().__init__(verbose)
        self.dir1_name = dir1_name
        self.dir2_name = dir2_name
```

2. Update format_match_group to use stored directory names:
```python
def format_match_group(self, file_hash: str, files_dir1: list[str], files_dir2: list[str]) -> None:
    print(f"Hash: {file_hash[:10]}...")
    print(f"  Files in {self.dir1_name}:")
    for f in files_dir1:
        print(f"    {f}")
    print(f"  Files in {self.dir2_name}:")
    for f in files_dir2:
        print(f"    {f}")
    print()
```

3. Update format_summary to use stored directory names:
```python
def format_summary(self, match_count: int, matched_files1: int, matched_files2: int, unmatched1: int, unmatched2: int) -> None:
    print(f"\nMatched files summary:")
    print(f"  Unique content hashes with matches: {match_count}")
    print(f"  Files in {self.dir1_name} with matches in {self.dir2_name}: {matched_files1}")
    print(f"  Files in {self.dir2_name} with matches in {self.dir1_name}: {matched_files2}")
```

4. Update format_unmatched to pass directory name from caller (no change needed - it already takes dir_label parameter).

Also update the CompareFormatter ABC's __init__ to accept these parameters:
```python
class CompareFormatter(ABC):
    """Abstract base class for compare mode output formatting."""

    def __init__(self, verbose: bool = False, dir1_name: str = "dir1", dir2_name: str = "dir2"):
        self.verbose = verbose
        self.dir1_name = dir1_name
        self.dir2_name = dir2_name
```
  </action>
  <verify>
```bash
python3 -c "
from file_matcher import TextCompareFormatter
f = TextCompareFormatter(verbose=False, dir1_name='/path/to/dir1', dir2_name='/path/to/dir2')
print(f'dir1: {f.dir1_name}')
print(f'dir2: {f.dir2_name}')
"
```
Should print the directory paths.
  </verify>
  <done>TextCompareFormatter accepts and uses directory names</done>
</task>

<task type="auto">
  <name>Task 2: Wire TextCompareFormatter into non-master compare mode</name>
  <files>file_matcher.py</files>
  <action>
In main(), locate the "Original output format (no master mode)" branch (~lines 1295-1340).

This is the `else` branch after `if master_path:`.

1. At the start of this else branch, instantiate the formatter:
```python
else:
    # Original output format (no master mode)
    compare_formatter = TextCompareFormatter(
        verbose=args.verbose,
        dir1_name=args.dir1,
        dir2_name=args.dir2
    )
```

2. Replace the summary output (lines 1297-1306):
```python
if args.summary:
    compare_formatter.format_summary(
        match_count=len(matches),
        matched_files1=matched_files1,
        matched_files2=matched_files2,
        unmatched1=len(unmatched1),
        unmatched2=len(unmatched2)
    )

    if args.show_unmatched:
        print(f"\nUnmatched files summary:")
        print(f"  Files in {args.dir1} with no match: {len(unmatched1)}")
        print(f"  Files in {args.dir2} with no match: {len(unmatched2)}")
```
Note: The unmatched summary format is different from unmatched file listing, keep it as direct print for now.

3. Replace the detailed output (lines 1307-1321):
```python
else:
    # Detailed output
    if not matches:
        print("No matching files with different names found.")
    else:
        print(f"\nFound {len(matches)} hashes with matching files:\n")
        for file_hash, (files1, files2) in matches.items():
            compare_formatter.format_match_group(file_hash, files1, files2)
```

4. Replace the unmatched files section (lines 1323-1340):
```python
    # Optionally display unmatched files (detailed mode)
    if args.show_unmatched and not args.summary:
        print("\nFiles with no content matches:")
        print("==============================")
        compare_formatter.format_unmatched(args.dir1, unmatched1)
        compare_formatter.format_unmatched(args.dir2, unmatched2)
```

5. At the end of this branch, call finalize:
```python
    compare_formatter.finalize()
```

CRITICAL: Preserve the exact output format including:
- The "No matching files with different names found." message
- The header "Found X hashes with matching files:"
- The separator lines for unmatched section
  </action>
  <verify>
```bash
cd /Users/patrick/dev/cursor_projects/filematcher && python3 file_matcher.py test_dir1 test_dir2 2>&1 | head -20
```
Should show "Found X hashes with matching files:" and hash groups.
  </verify>
  <done>Non-master compare mode uses TextCompareFormatter</done>
</task>

<task type="auto">
  <name>Task 3: Add MasterCompareFormatter for master compare mode</name>
  <files>file_matcher.py</files>
  <action>
The master compare mode (lines 1228-1294) has a different output format than basic compare mode. It uses [MASTER]/[DUP:?] labels and warnings.

Add a new formatter class for master compare mode:

```python
class MasterCompareFormatter(CompareFormatter):
    """Text output formatter for master compare mode (no action, but master directory set)."""

    def format_header(self, dir1: str, dir2: str, hash_algo: str) -> None:
        pass  # Header handled by logger

    def format_warnings(self, warnings: list[str]) -> None:
        """Format warnings about multiple files in master directory."""
        for warning in warnings:
            print(warning)
        if warnings:
            print()

    def format_master_group(
        self,
        master_file: str,
        duplicates: list[str],
        verbose: bool = False,
        file_sizes: dict[str, int] | None = None
    ) -> None:
        """Format a master/duplicate group."""
        # Use existing format_duplicate_group with action=None
        lines = format_duplicate_group(
            master_file=master_file,
            duplicates=duplicates,
            action=None,
            verbose=verbose,
            file_sizes=file_sizes,
            cross_fs_files=None,
            preview_mode=False
        )
        for line in lines:
            print(line)

    def format_match_group(self, file_hash: str, files_dir1: list[str], files_dir2: list[str]) -> None:
        # Not used in master mode - groups are formatted via format_master_group
        pass

    def format_unmatched(self, dir_label: str, files: list[str]) -> None:
        if files:
            print(f"\nUnique files in {dir_label} ({len(files)}):")
            for f in sorted(files):
                print(f"  {f}")
        else:
            print(f"\nNo unique files in {dir_label}")

    def format_master_summary(self, match_count: int, master_count: int, duplicate_count: int) -> None:
        """Format summary for master compare mode."""
        print(f"\nMatched files summary:")
        print(f"  Unique content hashes with matches: {match_count}")
        print(f"  Master files: {master_count}")
        print(f"  Duplicates: {duplicate_count}")

    def format_summary(self, match_count: int, matched_files1: int, matched_files2: int, unmatched1: int, unmatched2: int) -> None:
        # Delegate to format_master_summary for compatibility
        self.format_master_summary(match_count, matched_files1, matched_files2)

    def finalize(self) -> None:
        pass
```

Then wire it into the master compare mode branch (lines 1228-1294):

After `elif args.summary:` (line 1229), replace with:
```python
# Standard master mode (no action specified)
master_formatter = MasterCompareFormatter(verbose=args.verbose, dir1_name=args.dir1, dir2_name=args.dir2)

if args.summary:
    master_formatter.format_master_summary(
        match_count=len(matches),
        master_count=total_masters,
        duplicate_count=total_duplicates
    )

    if args.show_unmatched:
        print(f"\nUnmatched files summary:")
        print(f"  Files in {args.dir1} with no match: {len(unmatched1)}")
        print(f"  Files in {args.dir2} with no match: {len(unmatched2)}")
else:
    # Detailed output with master mode (no action)
    if not matches:
        print("No duplicates found.")
    else:
        print(f"\nFound {len(matches)} duplicate groups:\n")

        # Print warnings first
        master_formatter.format_warnings(warnings)

        # Sort master_results by master file path (alphabetical)
        sorted_results = sorted(master_results, key=lambda x: x[0])

        for i, (master_file, duplicates, reason) in enumerate(sorted_results):
            # Build file_sizes dict for verbose mode
            file_sizes = None
            if args.verbose:
                all_paths = [master_file] + duplicates
                file_sizes = {p: os.path.getsize(p) for p in all_paths}

            master_formatter.format_master_group(
                master_file, duplicates,
                verbose=args.verbose,
                file_sizes=file_sizes
            )

            # Print blank line between groups (but not after the last one)
            if i < len(sorted_results) - 1:
                print()

    # Optionally display unmatched files (detailed mode)
    if args.show_unmatched:
        print("\nFiles with no content matches:")
        print("==============================")
        master_formatter.format_unmatched(args.dir1, unmatched1)
        master_formatter.format_unmatched(args.dir2, unmatched2)

master_formatter.finalize()
```

NOTE: MasterCompareFormatter extends CompareFormatter but has additional master-specific methods. This is acceptable since it's still a compare mode formatter, just with master awareness.
  </action>
  <verify>
```bash
# Test master compare mode (note: --action triggers master mode, but we're testing without action here)
# Actually, master mode is triggered by --action, so test with action to see master format
cd /Users/patrick/dev/cursor_projects/filematcher && python3 file_matcher.py test_dir1 test_dir2 2>&1 | grep -E "(MASTER|DUP|Hash:)" | head -10
```
In non-action mode, should show "Hash:" format. With --action but no --execute, should show [MASTER] format.
  </verify>
  <done>Master compare mode uses MasterCompareFormatter</done>
</task>

</tasks>

<verification>
After all tasks complete:

1. Run full test suite:
```bash
cd /Users/patrick/dev/cursor_projects/filematcher && python3 run_tests.py
```
All tests must pass - output should be byte-identical to before.

2. Test non-master compare mode:
```bash
cd /Users/patrick/dev/cursor_projects/filematcher && python3 file_matcher.py test_dir1 test_dir2
```
Should show "Hash:" format groups.

3. Test non-master summary mode:
```bash
cd /Users/patrick/dev/cursor_projects/filematcher && python3 file_matcher.py test_dir1 test_dir2 --summary
```
Should show summary counts only.

4. Test unmatched files:
```bash
cd /Users/patrick/dev/cursor_projects/filematcher && python3 file_matcher.py test_dir1 test_dir2 --show-unmatched
```
Should show unmatched files sections.

5. Verify formatter classes exist:
```bash
python3 -c "from file_matcher import TextCompareFormatter, MasterCompareFormatter; print('Compare formatters imported')"
```
</verification>

<success_criteria>
1. TextCompareFormatter accepts directory names as parameters
2. Non-master compare mode uses TextCompareFormatter
3. MasterCompareFormatter handles master compare mode output
4. All existing CLI tests pass without modification
5. Output is byte-identical to previous implementation
</success_criteria>

<output>
After completion, create `.planning/phases/05-formatter-abstraction/05-03-SUMMARY.md`
</output>
