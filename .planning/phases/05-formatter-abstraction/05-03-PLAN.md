---
phase: 05-formatter-abstraction
plan: 03
type: execute
wave: 2
depends_on: ["05-01"]
files_modified:
  - file_matcher.py
  - tests/test_determinism.py
autonomous: true

must_haves:
  truths:
    - "Compare mode output routes through TextCompareFormatter"
    - "Output is byte-identical to current implementation"
    - "All existing tests pass without modification"
    - "Both master mode and non-master mode use formatter"
    - "Output is deterministic across multiple runs (OUT-04)"
  artifacts:
    - path: "file_matcher.py"
      provides: "Wired compare formatter in main()"
      contains: "TextCompareFormatter("
    - path: "tests/test_determinism.py"
      provides: "Determinism verification tests"
      contains: "class TestDeterminism"
  key_links:
    - from: "main() compare mode branches"
      to: "TextCompareFormatter"
      via: "formatter instantiation and method calls"
      pattern: "formatter\\.format_(match_group|summary|unmatched)"
---

<objective>
Wire TextCompareFormatter into main() to handle all compare mode output (no action specified), ensuring byte-identical output. Add determinism tests to verify OUT-04 compliance.

Purpose: Replace direct print() calls in compare mode with formatter method calls. Compare mode has two sub-modes: master mode (--action was NOT specified but we have master directory logic) and original mode (basic hash comparison). Also add comprehensive determinism testing.

Output: main() compare mode uses TextCompareFormatter, determinism tests added, all tests still passing.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/05-formatter-abstraction/05-CONTEXT.md
@.planning/phases/05-formatter-abstraction/05-RESEARCH.md
@.planning/phases/05-formatter-abstraction/05-01-SUMMARY.md
@file_matcher.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Extend TextCompareFormatter for directory names</name>
  <files>file_matcher.py</files>
  <action>
The current TextCompareFormatter uses hardcoded "dir1"/"dir2" labels. Update it to accept directory names:

1. Update TextCompareFormatter.__init__ to accept and store directory names:
```python
class TextCompareFormatter(CompareFormatter):
    """Text output formatter for compare mode (no action specified).

    Implements formatting inline - there are no existing format_* functions
    for compare mode to delegate to.
    """

    def __init__(self, verbose: bool = False, dir1_name: str = "dir1", dir2_name: str = "dir2"):
        super().__init__(verbose)
        self.dir1_name = dir1_name
        self.dir2_name = dir2_name
```

2. Update format_match_group to use stored directory names:
```python
def format_match_group(self, file_hash: str, files_dir1: list[str], files_dir2: list[str]) -> None:
    print(f"Hash: {file_hash[:10]}...")
    print(f"  Files in {self.dir1_name}:")
    for f in sorted(files_dir1):  # Sorted for determinism (OUT-04)
        print(f"    {f}")
    print(f"  Files in {self.dir2_name}:")
    for f in sorted(files_dir2):  # Sorted for determinism (OUT-04)
        print(f"    {f}")
    print()
```

3. Update format_summary to use stored directory names:
```python
def format_summary(self, match_count: int, matched_files1: int, matched_files2: int, unmatched1: int, unmatched2: int) -> None:
    print(f"\nMatched files summary:")
    print(f"  Unique content hashes with matches: {match_count}")
    print(f"  Files in {self.dir1_name} with matches in {self.dir2_name}: {matched_files1}")
    print(f"  Files in {self.dir2_name} with matches in {self.dir1_name}: {matched_files2}")
```

4. Update format_unmatched to pass directory name from caller (no change needed - it already takes dir_label parameter).

Also update the CompareFormatter ABC's __init__ to accept these parameters:
```python
class CompareFormatter(ABC):
    """Abstract base class for compare mode output formatting."""

    def __init__(self, verbose: bool = False, dir1_name: str = "dir1", dir2_name: str = "dir2"):
        self.verbose = verbose
        self.dir1_name = dir1_name
        self.dir2_name = dir2_name
```
  </action>
  <verify>
```bash
python3 -c "
from file_matcher import TextCompareFormatter
f = TextCompareFormatter(verbose=False, dir1_name='/path/to/dir1', dir2_name='/path/to/dir2')
print(f'dir1: {f.dir1_name}')
print(f'dir2: {f.dir2_name}')
"
```
Should print the directory paths.
  </verify>
  <done>TextCompareFormatter accepts and uses directory names</done>
</task>

<task type="auto">
  <name>Task 2: Wire TextCompareFormatter into non-master compare mode</name>
  <files>file_matcher.py</files>
  <action>
In main(), locate the "Original output format (no master mode)" branch (~lines 1295-1340).

This is the `else` branch after `if master_path:`.

1. At the start of this else branch, instantiate the formatter:
```python
else:
    # Original output format (no master mode)
    compare_formatter = TextCompareFormatter(
        verbose=args.verbose,
        dir1_name=args.dir1,
        dir2_name=args.dir2
    )
```

2. Replace the summary output (lines 1297-1306):
```python
if args.summary:
    compare_formatter.format_summary(
        match_count=len(matches),
        matched_files1=matched_files1,
        matched_files2=matched_files2,
        unmatched1=len(unmatched1),
        unmatched2=len(unmatched2)
    )

    if args.show_unmatched:
        print(f"\nUnmatched files summary:")
        print(f"  Files in {args.dir1} with no match: {len(unmatched1)}")
        print(f"  Files in {args.dir2} with no match: {len(unmatched2)}")
```
Note: The unmatched summary format is different from unmatched file listing, keep it as direct print for now.

3. Replace the detailed output (lines 1307-1321):
```python
else:
    # Detailed output
    if not matches:
        print("No matching files with different names found.")
    else:
        print(f"\nFound {len(matches)} hashes with matching files:\n")
        # Sort hash keys for deterministic output (OUT-04)
        for file_hash in sorted(matches.keys()):
            files1, files2 = matches[file_hash]
            compare_formatter.format_match_group(file_hash, files1, files2)
```

4. Replace the unmatched files section (lines 1323-1340):
```python
    # Optionally display unmatched files (detailed mode)
    if args.show_unmatched and not args.summary:
        print("\nFiles with no content matches:")
        print("==============================")
        compare_formatter.format_unmatched(args.dir1, unmatched1)
        compare_formatter.format_unmatched(args.dir2, unmatched2)
```

5. At the end of this branch, call finalize:
```python
    compare_formatter.finalize()
```

CRITICAL: Preserve the exact output format including:
- The "No matching files with different names found." message
- The header "Found X hashes with matching files:"
- The separator lines for unmatched section
- Sort matches.keys() for deterministic hash iteration (OUT-04)
  </action>
  <verify>
```bash
cd /Users/patrick/dev/cursor_projects/filematcher && python3 file_matcher.py test_dir1 test_dir2 2>&1 | head -20
```
Should show "Found X hashes with matching files:" and hash groups.
  </verify>
  <done>Non-master compare mode uses TextCompareFormatter with sorted hash iteration</done>
</task>

<task type="auto">
  <name>Task 3: Add determinism tests (OUT-04 verification)</name>
  <files>tests/test_determinism.py</files>
  <action>
Create a new test file to verify deterministic output (OUT-04):

```python
"""Tests for output determinism (OUT-04).

Verifies that running the same command multiple times produces
identical output, regardless of hash iteration order or filesystem
ordering.
"""

import unittest
import subprocess
import sys
import os

# Add parent directory to path for imports
sys.path.insert(0, os.path.dirname(os.path.dirname(os.path.abspath(__file__))))


class TestDeterminism(unittest.TestCase):
    """Test that output is deterministic across multiple runs."""

    def test_compare_mode_determinism(self):
        """Compare mode produces identical output on repeated runs."""
        cmd = [sys.executable, 'file_matcher.py', 'test_dir1', 'test_dir2']

        # Run 5 times and compare
        outputs = []
        for _ in range(5):
            result = subprocess.run(
                cmd,
                capture_output=True,
                text=True,
                cwd=os.path.dirname(os.path.dirname(os.path.abspath(__file__)))
            )
            outputs.append(result.stdout)

        # All outputs should be identical
        for i, output in enumerate(outputs[1:], start=2):
            self.assertEqual(
                outputs[0], output,
                f"Run 1 and run {i} produced different output"
            )

    def test_action_mode_determinism(self):
        """Action mode produces identical output on repeated runs."""
        cmd = [
            sys.executable, 'file_matcher.py',
            'test_dir1', 'test_dir2',
            '--action', 'hardlink'
        ]

        outputs = []
        for _ in range(5):
            result = subprocess.run(
                cmd,
                capture_output=True,
                text=True,
                cwd=os.path.dirname(os.path.dirname(os.path.abspath(__file__)))
            )
            outputs.append(result.stdout)

        for i, output in enumerate(outputs[1:], start=2):
            self.assertEqual(
                outputs[0], output,
                f"Run 1 and run {i} produced different output"
            )

    def test_unmatched_mode_determinism(self):
        """Unmatched files output is deterministic."""
        cmd = [
            sys.executable, 'file_matcher.py',
            'test_dir1', 'test_dir2',
            '--show-unmatched'
        ]

        outputs = []
        for _ in range(5):
            result = subprocess.run(
                cmd,
                capture_output=True,
                text=True,
                cwd=os.path.dirname(os.path.dirname(os.path.abspath(__file__)))
            )
            outputs.append(result.stdout)

        for i, output in enumerate(outputs[1:], start=2):
            self.assertEqual(
                outputs[0], output,
                f"Run 1 and run {i} produced different output"
            )

    def test_verbose_mode_determinism(self):
        """Verbose mode produces identical output on repeated runs."""
        cmd = [
            sys.executable, 'file_matcher.py',
            'test_dir1', 'test_dir2',
            '--action', 'hardlink',
            '--verbose'
        ]

        outputs = []
        for _ in range(5):
            result = subprocess.run(
                cmd,
                capture_output=True,
                text=True,
                cwd=os.path.dirname(os.path.dirname(os.path.abspath(__file__)))
            )
            outputs.append(result.stdout)

        for i, output in enumerate(outputs[1:], start=2):
            self.assertEqual(
                outputs[0], output,
                f"Run 1 and run {i} produced different output"
            )


if __name__ == '__main__':
    unittest.main()
```

Update run_tests.py to include the new test module (if not auto-discovered).
  </action>
  <verify>
```bash
cd /Users/patrick/dev/cursor_projects/filematcher && python3 -m tests.test_determinism
```
All determinism tests should pass.
  </verify>
  <done>Determinism tests added to verify OUT-04 compliance across all output modes</done>
</task>

</tasks>

<verification>
After all tasks complete:

1. Run full test suite:
```bash
cd /Users/patrick/dev/cursor_projects/filematcher && python3 run_tests.py
```
All tests must pass - output should be byte-identical to before.

2. Run determinism tests specifically:
```bash
cd /Users/patrick/dev/cursor_projects/filematcher && python3 -m tests.test_determinism -v
```
All 4 determinism tests should pass.

3. Test non-master compare mode:
```bash
cd /Users/patrick/dev/cursor_projects/filematcher && python3 file_matcher.py test_dir1 test_dir2
```
Should show "Hash:" format groups.

4. Test non-master summary mode:
```bash
cd /Users/patrick/dev/cursor_projects/filematcher && python3 file_matcher.py test_dir1 test_dir2 --summary
```
Should show summary counts only.

5. Test unmatched files:
```bash
cd /Users/patrick/dev/cursor_projects/filematcher && python3 file_matcher.py test_dir1 test_dir2 --show-unmatched
```
Should show unmatched files sections.

6. Verify formatter classes exist:
```bash
python3 -c "from file_matcher import TextCompareFormatter; print('Compare formatters imported')"
```

7. Verify determinism manually (run twice, compare):
```bash
cd /Users/patrick/dev/cursor_projects/filematcher && \
  python3 file_matcher.py test_dir1 test_dir2 > /tmp/out1.txt && \
  python3 file_matcher.py test_dir1 test_dir2 > /tmp/out2.txt && \
  diff /tmp/out1.txt /tmp/out2.txt && echo "Deterministic: outputs match"
```
</verification>

<success_criteria>
1. TextCompareFormatter accepts directory names as parameters
2. Non-master compare mode uses TextCompareFormatter
3. Hash iteration is sorted for deterministic output (OUT-04)
4. File lists within groups are sorted (OUT-04)
5. Unmatched files are sorted (OUT-04)
6. Determinism tests pass (5 runs produce identical output)
7. All existing CLI tests pass without modification
8. Output is byte-identical to previous implementation
</success_criteria>

<output>
After completion, create `.planning/phases/05-formatter-abstraction/05-03-SUMMARY.md`
</output>
