---
phase: 05-formatter-abstraction
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - file_matcher.py
autonomous: true

must_haves:
  truths:
    - "OutputFormatter ABC hierarchy exists (CompareFormatter, ActionFormatter)"
    - "TextCompareFormatter produces byte-identical output to current compare mode"
    - "TextActionFormatter produces byte-identical output to current action mode"
    - "All existing tests pass without modification"
    - "Output is deterministic (sorted by file paths)"
  artifacts:
    - path: "file_matcher.py"
      provides: "ABC definitions and Text formatter implementations"
      contains: "class CompareFormatter(ABC)"
    - path: "file_matcher.py"
      provides: "ActionFormatter base class"
      contains: "class ActionFormatter(ABC)"
    - path: "file_matcher.py"
      provides: "TextCompareFormatter implementation"
      contains: "class TextCompareFormatter(CompareFormatter)"
    - path: "file_matcher.py"
      provides: "TextActionFormatter implementation"
      contains: "class TextActionFormatter(ActionFormatter)"
  key_links:
    - from: "TextCompareFormatter methods"
      to: "inline print statements"
      via: "direct implementation (no existing format_* functions for compare mode)"
      pattern: "print\\(f\"Hash:"
    - from: "TextActionFormatter methods"
      to: "existing format_* functions"
      via: "delegation (calls existing functions)"
      pattern: "format_duplicate_group|format_statistics_footer|format_preview_banner|format_execute_banner"
---

<objective>
Define the OutputFormatter ABC hierarchy with CompareFormatter and ActionFormatter base classes, plus TextCompareFormatter and TextActionFormatter implementations.

Purpose: Create the foundation for multiple output formats (text, JSON in Phase 6) without changing user-visible behavior. This is pure refactoring - output must be byte-identical.

Output: ABC definitions and TextFormatter implementations in file_matcher.py, all tests still passing.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/05-formatter-abstraction/05-CONTEXT.md
@.planning/phases/05-formatter-abstraction/05-RESEARCH.md
@file_matcher.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Define CompareFormatter and ActionFormatter ABCs</name>
  <files>file_matcher.py</files>
  <action>
Add imports at top of file (after existing imports):
```python
from abc import ABC, abstractmethod
```

After the existing logging setup (~line 22), add the ABC definitions:

1. CompareFormatter ABC with methods:
   - `__init__(self, verbose: bool = False)` - store config
   - `@abstractmethod format_header(self, dir1: str, dir2: str, hash_algo: str) -> None`
   - `@abstractmethod format_match_group(self, file_hash: str, files_dir1: list[str], files_dir2: list[str]) -> None`
   - `@abstractmethod format_unmatched(self, dir_label: str, files: list[str]) -> None`
   - `@abstractmethod format_summary(self, match_count: int, matched_files1: int, matched_files2: int, unmatched1: int, unmatched2: int) -> None`
   - `@abstractmethod finalize(self) -> None`

2. ActionFormatter ABC with methods:
   - `__init__(self, verbose: bool = False, preview_mode: bool = True)` - store config
   - `@abstractmethod format_banner(self) -> None`
   - `@abstractmethod format_warnings(self, warnings: list[str]) -> None`
   - `@abstractmethod format_duplicate_group(self, master_file: str, duplicates: list[str], action: str, file_sizes: dict[str, int] | None = None, cross_fs_files: set[str] | None = None) -> None`
   - `@abstractmethod format_statistics(self, group_count: int, duplicate_count: int, master_count: int, space_savings: int, action: str, cross_fs_count: int = 0) -> None`
   - `@abstractmethod format_execution_summary(self, success_count: int, failure_count: int, skipped_count: int, space_saved: int, log_path: str, failed_list: list[tuple[str, str]]) -> None`
   - `@abstractmethod finalize(self) -> None`

Place these ABCs BEFORE the existing format_* functions (before line 93).
  </action>
  <verify>
```bash
python3 -c "from file_matcher import CompareFormatter, ActionFormatter; print('ABC imports work')"
```
Should print "ABC imports work" without errors.
  </verify>
  <done>CompareFormatter and ActionFormatter ABCs defined with all required abstract methods</done>
</task>

<task type="auto">
  <name>Task 2: Implement TextCompareFormatter</name>
  <files>file_matcher.py</files>
  <action>
After the ActionFormatter ABC definition, add TextCompareFormatter.

NOTE: There are NO existing format_* functions for compare mode output. TextCompareFormatter implements formatting INLINE (direct print statements), matching the current output in main() lines 1307-1340.

```python
class TextCompareFormatter(CompareFormatter):
    """Text output formatter for compare mode (no action specified).

    Implements formatting inline - there are no existing format_* functions
    for compare mode to delegate to.
    """

    def format_header(self, dir1: str, dir2: str, hash_algo: str) -> None:
        # Header is printed by logger in main(), not by formatter
        # This method exists for interface completeness
        pass

    def format_match_group(self, file_hash: str, files_dir1: list[str], files_dir2: list[str]) -> None:
        # Inline implementation matching current output format
        print(f"Hash: {file_hash[:10]}...")
        print(f"  Files in dir1:")  # Will be replaced with actual dir names by caller
        for f in sorted(files_dir1):  # Sorted for determinism (OUT-04)
            print(f"    {f}")
        print(f"  Files in dir2:")
        for f in sorted(files_dir2):  # Sorted for determinism (OUT-04)
            print(f"    {f}")
        print()

    def format_unmatched(self, dir_label: str, files: list[str]) -> None:
        if files:
            print(f"\nUnique files in {dir_label} ({len(files)}):")
            for f in sorted(files):  # Sorted for determinism (OUT-04)
                print(f"  {f}")
        else:
            print(f"\nNo unique files in {dir_label}")

    def format_summary(self, match_count: int, matched_files1: int, matched_files2: int, unmatched1: int, unmatched2: int) -> None:
        print(f"\nMatched files summary:")
        print(f"  Unique content hashes with matches: {match_count}")
        print(f"  Files in dir1 with matches: {matched_files1}")
        print(f"  Files in dir2 with matches: {matched_files2}")

    def finalize(self) -> None:
        pass  # Text output is immediate
```

CRITICAL: Sort file lists in format_match_group and format_unmatched to ensure deterministic output (OUT-04).
  </action>
  <verify>
```bash
python3 -c "from file_matcher import TextCompareFormatter; f = TextCompareFormatter(); print('TextCompareFormatter instantiates')"
```
Should print "TextCompareFormatter instantiates" without errors.
  </verify>
  <done>TextCompareFormatter implements CompareFormatter ABC with inline formatting that matches existing output patterns, with sorted file lists for determinism</done>
</task>

<task type="auto">
  <name>Task 3: Implement TextActionFormatter</name>
  <files>file_matcher.py</files>
  <action>
After TextCompareFormatter, add TextActionFormatter that DELEGATES to existing format_* functions:

```python
class TextActionFormatter(ActionFormatter):
    """Text output formatter for action mode (preview/execute).

    Delegates to existing format_* functions to ensure byte-identical output.
    """

    def format_banner(self) -> None:
        if self.preview_mode:
            print(format_preview_banner())
        else:
            print(format_execute_banner())
        print()

    def format_warnings(self, warnings: list[str]) -> None:
        for warning in warnings:
            print(warning)
        if warnings:
            print()

    def format_duplicate_group(
        self,
        master_file: str,
        duplicates: list[str],
        action: str,
        file_sizes: dict[str, int] | None = None,
        cross_fs_files: set[str] | None = None
    ) -> None:
        # DELEGATE to existing format_duplicate_group function
        # Note: format_duplicate_group already sorts duplicates (line 144)
        lines = format_duplicate_group(
            master_file=master_file,
            duplicates=duplicates,
            action=action,
            verbose=self.verbose,
            file_sizes=file_sizes,
            cross_fs_files=cross_fs_files,
            preview_mode=self.preview_mode
        )
        for line in lines:
            print(line)

    def format_statistics(
        self,
        group_count: int,
        duplicate_count: int,
        master_count: int,
        space_savings: int,
        action: str,
        cross_fs_count: int = 0
    ) -> None:
        # DELEGATE to existing format_statistics_footer function
        lines = format_statistics_footer(
            group_count=group_count,
            duplicate_count=duplicate_count,
            master_count=master_count,
            space_savings=space_savings,
            action=action,
            verbose=self.verbose,
            cross_fs_count=cross_fs_count,
            preview_mode=self.preview_mode
        )
        for line in lines:
            print(line)

    def format_execution_summary(
        self,
        success_count: int,
        failure_count: int,
        skipped_count: int,
        space_saved: int,
        log_path: str,
        failed_list: list[tuple[str, str]]
    ) -> None:
        print()
        print(f"Execution complete:")
        print(f"  Successful: {success_count}")
        print(f"  Failed: {failure_count}")
        print(f"  Skipped: {skipped_count}")
        print(f"  Space saved: {format_file_size(space_saved)}")
        print(f"  Log file: {log_path}")
        if failed_list:
            print()
            print("Failed files:")
            for path, error in sorted(failed_list):  # Sorted for determinism (OUT-04)
                print(f"  - {path}: {error}")

    def finalize(self) -> None:
        pass  # Text output is immediate
```

CRITICAL:
1. TextActionFormatter MUST delegate to format_duplicate_group() and format_statistics_footer() functions
2. The existing format_duplicate_group already sorts duplicates (line 144: `for dup in sorted(duplicates)`)
3. Sort failed_list in format_execution_summary for determinism (OUT-04)
  </action>
  <verify>
```bash
python3 -c "from file_matcher import TextActionFormatter; f = TextActionFormatter(verbose=True, preview_mode=True); print('TextActionFormatter instantiates')"
```
Should print "TextActionFormatter instantiates" without errors.
  </verify>
  <done>TextActionFormatter implements ActionFormatter ABC with delegation to existing format_* functions, maintaining deterministic ordering</done>
</task>

</tasks>

<verification>
After all tasks complete:

1. Run full test suite:
```bash
python3 run_tests.py
```
All tests must pass - we have not yet wired formatters into main(), so output is unchanged.

2. Verify ABC structure:
```bash
python3 -c "
from file_matcher import CompareFormatter, ActionFormatter, TextCompareFormatter, TextActionFormatter
from abc import ABC
print(f'CompareFormatter is ABC: {issubclass(CompareFormatter, ABC)}')
print(f'ActionFormatter is ABC: {issubclass(ActionFormatter, ABC)}')
print(f'TextCompareFormatter inherits CompareFormatter: {issubclass(TextCompareFormatter, CompareFormatter)}')
print(f'TextActionFormatter inherits ActionFormatter: {issubclass(TextActionFormatter, ActionFormatter)}')
"
```
All should print True.

3. Verify ABC enforcement (cannot instantiate abstract class):
```bash
python3 -c "
from file_matcher import CompareFormatter
try:
    f = CompareFormatter()
    print('ERROR: Should not instantiate ABC')
except TypeError as e:
    print(f'Good: {e}')
"
```
Should show TypeError about abstract methods.

4. Verify determinism in sorting (OUT-04):
```bash
python3 -c "
from file_matcher import TextCompareFormatter
import io
import sys

# Capture output
old_stdout = sys.stdout
sys.stdout = io.StringIO()

f = TextCompareFormatter()
# Test with unsorted input - should produce sorted output
f.format_match_group('abc123', ['z_file.txt', 'a_file.txt'], ['m_file.txt', 'b_file.txt'])

output = sys.stdout.getvalue()
sys.stdout = old_stdout

# Verify files are sorted
lines = output.strip().split('\n')
dir1_files = [l.strip() for l in lines if l.strip().endswith('.txt') and 'dir1' not in l][:2]
print(f'Files sorted in output: {dir1_files == sorted(dir1_files)}')
"
```
Should print True.
</verification>

<success_criteria>
1. CompareFormatter ABC exists with 5 abstract methods
2. ActionFormatter ABC exists with 6 abstract methods
3. TextCompareFormatter implements all CompareFormatter methods with inline formatting
4. TextActionFormatter implements all ActionFormatter methods (delegating to existing format_* functions)
5. All file lists are sorted for deterministic output (OUT-04)
6. All existing tests pass without modification
7. ABC enforcement works (cannot instantiate base classes)
</success_criteria>

<output>
After completion, create `.planning/phases/05-formatter-abstraction/05-01-SUMMARY.md`
</output>
