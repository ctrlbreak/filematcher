---
phase: 06-json-output
plan: 03
type: execute
wave: 3
depends_on: [06-02]
files_modified: [tests/test_json_output.py, README.md]
autonomous: true

must_haves:
  truths:
    - "JSON output tests validate all major code paths"
    - "Tests verify JSON structure matches documented schema"
    - "README documents JSON schema with field descriptions and examples"
    - "jq extraction examples help users get started quickly"
  artifacts:
    - path: "tests/test_json_output.py"
      provides: "JSON output test suite"
      min_lines: 100
    - path: "README.md"
      provides: "JSON schema documentation"
      contains: "--json"
  key_links:
    - from: "tests/test_json_output.py"
      to: "file_matcher.py"
      via: "imports and subprocess calls"
      pattern: "from file_matcher import|subprocess.*file_matcher"
---

<objective>
Add comprehensive tests for JSON output and document the JSON schema in README.

Purpose: Tests ensure JSON output reliability across flag combinations. Documentation helps users understand and use the JSON output effectively with jq.

Output: New test file with JSON-specific tests, README updated with JSON schema and jq examples.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/06-json-output/06-CONTEXT.md
@.planning/phases/06-json-output/06-02-SUMMARY.md
@tests/test_cli.py (for test patterns)
@tests/test_determinism.py (for test patterns)
@README.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create JSON output test suite</name>
  <files>tests/test_json_output.py</files>
  <action>
Create new test file `tests/test_json_output.py` with comprehensive JSON output tests.

**Test structure:**
```python
"""Tests for JSON output functionality (--json flag)."""

import json
import os
import subprocess
import tempfile
import unittest
from pathlib import Path

# Import base test class for temp directory helpers
from tests.test_base import BaseFileMatcherTest


class TestJsonOutput(BaseFileMatcherTest):
    """Test JSON output in compare mode."""

    def run_with_json(self, *args):
        """Helper to run file_matcher with --json and parse output."""
        cmd = ['python3', 'file_matcher.py', '--json'] + list(args)
        result = subprocess.run(cmd, capture_output=True, text=True)
        return result, json.loads(result.stdout) if result.returncode == 0 else None
```

**Required test cases:**

1. **Basic structure tests:**
   - `test_json_output_is_valid_json` - Output parses as JSON
   - `test_json_has_required_fields` - timestamp, directories, hashAlgorithm, matches, summary
   - `test_json_timestamp_format` - RFC 3339 format validation
   - `test_json_directories_absolute_paths` - Paths are absolute

2. **Compare mode tests:**
   - `test_json_matches_structure` - Each match has hash, filesDir1, filesDir2
   - `test_json_unmatched_with_flag` - --show-unmatched includes arrays
   - `test_json_unmatched_without_flag` - Without flag, arrays empty/missing
   - `test_json_summary_only` - --summary produces minimal output
   - `test_json_verbose_includes_metadata` - --verbose adds file metadata

3. **Action mode tests:**
   - `test_json_action_mode_structure` - Has mode, action, duplicateGroups
   - `test_json_action_preview_mode` - mode is "preview" without --execute
   - `test_json_action_execute_requires_yes` - Error without --yes

4. **Determinism tests:**
   - `test_json_output_deterministic` - Same input produces identical JSON
   - `test_json_matches_sorted` - Matches sorted by first file in dir1
   - `test_json_files_within_groups_sorted` - filesDir1, filesDir2 sorted

5. **Field naming tests:**
   - `test_json_camel_case_fields` - Verify camelCase (not snake_case)

6. **Integration tests:**
   - `test_json_with_hash_sha256` - hashAlgorithm shows correct value
   - `test_json_with_different_names_only` - Filter applied before JSON

**Test file location:** `tests/test_json_output.py`

Use existing test infrastructure from test_base.py (temp directories, test files).
  </action>
  <verify>
Run the new tests:
`python3 -m tests.test_json_output`

All tests should pass.
  </verify>
  <done>
tests/test_json_output.py exists with comprehensive JSON output tests covering structure, flags, determinism, and field naming.
  </done>
</task>

<task type="auto">
  <name>Task 2: Document JSON schema in README</name>
  <files>README.md</files>
  <action>
Add JSON output documentation section to README.md.

**Location:** Add new section after existing usage documentation, before any "Development" or "Testing" sections.

**Section structure:**

```markdown
## JSON Output

Use `--json` or `-j` to get machine-readable JSON output for scripting and automation.

### Basic Usage

```bash
# Compare mode
filematcher dir1 dir2 --json

# Action mode
filematcher dir1 dir2 --action hardlink --json

# Execute with JSON output (requires --yes)
filematcher dir1 dir2 --action hardlink --execute --yes --json
```

### Schema (Compare Mode)

| Field | Type | Description |
|-------|------|-------------|
| `timestamp` | string | Execution time (RFC 3339 format) |
| `directories.dir1` | string | First directory path (absolute) |
| `directories.dir2` | string | Second directory path (absolute) |
| `hashAlgorithm` | string | Hash algorithm used ("md5" or "sha256") |
| `matches` | array | Groups of files with matching content |
| `matches[].hash` | string | Content hash for the group |
| `matches[].filesDir1` | array | File paths from dir1 |
| `matches[].filesDir2` | array | File paths from dir2 |
| `unmatchedDir1` | array | Unmatched files in dir1 (with --show-unmatched) |
| `unmatchedDir2` | array | Unmatched files in dir2 (with --show-unmatched) |
| `summary.matchGroups` | number | Number of unique content hashes |
| `summary.matchedFilesDir1` | number | Files with matches in dir1 |
| `summary.matchedFilesDir2` | number | Files with matches in dir2 |

### Schema (Action Mode)

| Field | Type | Description |
|-------|------|-------------|
| `timestamp` | string | Execution time (RFC 3339) |
| `mode` | string | "preview" or "execute" |
| `action` | string | "hardlink", "symlink", or "delete" |
| `directories.master` | string | Master directory path |
| `directories.duplicate` | string | Duplicate directory path |
| `warnings` | array | Warning messages |
| `duplicateGroups` | array | Groups of duplicates |
| `duplicateGroups[].masterFile` | string | Master file path |
| `duplicateGroups[].duplicates` | array | Duplicate file objects |
| `duplicateGroups[].duplicates[].path` | string | Duplicate file path |
| `duplicateGroups[].duplicates[].sizeBytes` | number | File size in bytes |
| `statistics.groupCount` | number | Number of duplicate groups |
| `statistics.duplicateCount` | number | Total duplicate files |
| `statistics.spaceSavings` | number | Bytes that would be saved |

### jq Examples

```bash
# List all matching file pairs
filematcher dir1 dir2 --json | jq -r '.matches[] | "\(.filesDir1[0]) <-> \(.filesDir2[0])"'

# Get total space that would be saved
filematcher dir1 dir2 --action hardlink --json | jq '.statistics.spaceSavings'

# List only duplicate paths
filematcher dir1 dir2 --action hardlink --json | jq -r '.duplicateGroups[].duplicates[].path'

# Count matches
filematcher dir1 dir2 --json | jq '.summary.matchGroups'

# Filter large duplicates (>1MB)
filematcher dir1 dir2 --action hardlink --json | jq '[.duplicateGroups[].duplicates[] | select(.sizeBytes > 1048576)]'
```

### Flag Interactions

| Flags | Behavior |
|-------|----------|
| `--json --summary` | Only summary statistics, no file details |
| `--json --verbose` | Includes per-file metadata (size, modified time) |
| `--json --show-unmatched` | Includes unmatched file arrays |
| `--json --execute` | Requires `--yes` (no interactive prompts) |
```

**Important:** Match field names exactly to implementation (camelCase).
  </action>
  <verify>
Check README has the new section:
`grep -c "JSON Output" README.md` - should be at least 1
`grep -c "jq Examples" README.md` - should be at least 1
  </verify>
  <done>
README.md contains JSON output documentation with schema tables and jq examples.
  </done>
</task>

</tasks>

<verification>
After both tasks:
1. `python3 -m tests.test_json_output` - all new tests pass
2. `python3 run_tests.py` - all tests pass (existing + new)
3. `grep "JSON Output" README.md` - documentation section exists
4. jq examples in README are accurate (can be tested manually)
</verification>

<success_criteria>
- tests/test_json_output.py contains comprehensive JSON output tests
- All tests pass (new and existing)
- README.md documents JSON schema with field descriptions
- README.md includes practical jq examples
- Schema in docs matches actual implementation
</success_criteria>

<output>
After completion, create `.planning/phases/06-json-output/06-03-SUMMARY.md`
</output>
