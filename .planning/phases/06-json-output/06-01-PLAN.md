---
phase: 06-json-output
plan: 01
type: execute
wave: 1
depends_on: []
files_modified: [file_matcher.py]
autonomous: true

must_haves:
  truths:
    - "JsonCompareFormatter produces valid JSON when used in compare mode"
    - "JsonActionFormatter produces valid JSON when used in action mode"
    - "JSON output includes all required metadata fields"
    - "JSON output is deterministic (same input produces identical output)"
  artifacts:
    - path: "file_matcher.py"
      provides: "JsonCompareFormatter and JsonActionFormatter classes"
      contains: "class JsonCompareFormatter"
    - path: "file_matcher.py"
      provides: "JsonActionFormatter class"
      contains: "class JsonActionFormatter"
  key_links:
    - from: "JsonCompareFormatter"
      to: "CompareFormatter ABC"
      via: "inheritance"
      pattern: "class JsonCompareFormatter\\(CompareFormatter\\)"
    - from: "JsonActionFormatter"
      to: "ActionFormatter ABC"
      via: "inheritance"
      pattern: "class JsonActionFormatter\\(ActionFormatter\\)"
---

<objective>
Implement JsonCompareFormatter and JsonActionFormatter classes that extend the Phase 5 ABC hierarchy.

Purpose: These formatters will accumulate data and serialize to JSON, providing machine-readable output for scripting and automation.

Output: Two new formatter classes in file_matcher.py ready to be wired into main() in the next plan.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-json-output/06-RESEARCH.md
@.planning/phases/06-json-output/06-CONTEXT.md
@.planning/phases/05-formatter-abstraction/05-01-SUMMARY.md
@file_matcher.py (lines 31-198 for ABC definitions)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement JsonCompareFormatter</name>
  <files>file_matcher.py</files>
  <action>
Create JsonCompareFormatter class that extends CompareFormatter ABC.

**Implementation pattern (accumulator):**
- Initialize `self._data` dict in `__init__` with structure matching CONTEXT.md decisions
- Each format_* method accumulates data into `self._data`
- `finalize()` sorts collections and calls `json.dumps(self._data, indent=2)`

**Required structure (from CONTEXT.md):**
```python
self._data = {
    "timestamp": "",           # RFC 3339 execution timestamp
    "directories": {
        "dir1": "",            # Absolute path
        "dir2": ""             # Absolute path
    },
    "hashAlgorithm": "",       # "md5" or "sha256"
    "matches": [],             # Array of match groups
    "unmatchedDir1": [],       # Array of file paths (if --show-unmatched)
    "unmatchedDir2": [],       # Array of file paths (if --show-unmatched)
    "summary": {}              # Statistics
}
```

**Match group structure:**
```python
{
    "hash": "abc123...",
    "filesDir1": ["path1", "path2"],
    "filesDir2": ["path3"]
}
```

**Field naming:** Use camelCase per CONTEXT.md (filePath, filesDir1, not file_path, files_dir1).

**Sorting:** Sort all lists for determinism:
- matches sorted by (first file in dir1, hash)
- filesDir1 and filesDir2 sorted alphabetically
- unmatchedDir1 and unmatchedDir2 sorted alphabetically

**Imports needed at top of file:**
- `import json` (may already exist - check)
- `from datetime import timezone` (datetime already imported)

**Verbose mode:** When self.verbose is True, add per-file metadata:
```python
"metadata": {
    "/path/to/file": {
        "sizeBytes": 12345,
        "modified": "2026-01-22T10:30:45+00:00"
    }
}
```

Place the class immediately after TextCompareFormatter (around line 268).
  </action>
  <verify>
Run `python3 -c "from file_matcher import JsonCompareFormatter; print('OK')"` - should print OK with no errors.
  </verify>
  <done>
JsonCompareFormatter class exists, extends CompareFormatter, implements all abstract methods, and can be imported without errors.
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement JsonActionFormatter</name>
  <files>file_matcher.py</files>
  <action>
Create JsonActionFormatter class that extends ActionFormatter ABC.

**Implementation pattern (accumulator):**
- Initialize `self._data` dict in `__init__`
- Each format_* method accumulates data into `self._data`
- `finalize()` sorts collections and calls `json.dumps(self._data, indent=2)`

**Required structure:**
```python
self._data = {
    "timestamp": "",           # RFC 3339 execution timestamp
    "mode": "",                # "preview" or "execute"
    "action": "",              # "hardlink", "symlink", "delete"
    "directories": {
        "master": "",          # Master directory path
        "duplicate": ""        # Directory containing duplicates
    },
    "warnings": [],            # Array of warning strings
    "duplicateGroups": [],     # Array of duplicate group objects
    "statistics": {},          # Group count, duplicate count, space savings
    "execution": {}            # Only present in execute mode
}
```

**Duplicate group structure:**
```python
{
    "masterFile": "/path/to/master",
    "duplicates": [
        {
            "path": "/path/to/dup",
            "sizeBytes": 12345,
            "action": "hardlink",        # or "symlink", "delete"
            "crossFilesystem": false     # True if can't hardlink
        }
    ]
}
```

**Execution results structure (only in execute mode, format_execution_summary):**
```python
"execution": {
    "successCount": 5,
    "failureCount": 1,
    "skippedCount": 0,
    "spaceSaved": 123456,
    "logPath": "/path/to/audit.log",
    "failures": [
        {"path": "/path/to/file", "error": "Permission denied"}
    ]
}
```

**Field naming:** Use camelCase (masterFile, sizeBytes, crossFilesystem).

**Sorting:** Sort duplicateGroups by master file path, sort duplicates within each group by path.

**Verbose mode:** Include sizeBytes in duplicate objects. In non-verbose, still include sizeBytes (needed for space calculations).

Place the class immediately after JsonCompareFormatter.
  </action>
  <verify>
Run `python3 -c "from file_matcher import JsonActionFormatter; print('OK')"` - should print OK with no errors.
  </verify>
  <done>
JsonActionFormatter class exists, extends ActionFormatter, implements all abstract methods, and can be imported without errors.
  </done>
</task>

</tasks>

<verification>
After both tasks:
1. `python3 -c "from file_matcher import JsonCompareFormatter, JsonActionFormatter; print('OK')"` succeeds
2. `python3 run_tests.py` - all 110 existing tests still pass (no regressions)
3. Both classes implement all abstract methods from their respective ABCs
</verification>

<success_criteria>
- JsonCompareFormatter fully implements CompareFormatter ABC with accumulator pattern
- JsonActionFormatter fully implements ActionFormatter ABC with accumulator pattern
- Both produce deterministic, valid JSON when finalize() is called
- camelCase field names per CONTEXT.md
- RFC 3339 timestamps for all time fields
- All existing tests pass (text output unchanged)
</success_criteria>

<output>
After completion, create `.planning/phases/06-json-output/06-01-SUMMARY.md`
</output>
