---
phase: 08-color-enhancement
plan: 01
type: execute
wave: 1
depends_on: []
files_modified: [file_matcher.py]
autonomous: true

must_haves:
  truths:
    - "ColorMode enum exists with AUTO, NEVER, ALWAYS values"
    - "ColorConfig class determines color state from mode, environment, and stream TTY"
    - "NO_COLOR environment variable disables color in AUTO mode"
    - "FORCE_COLOR environment variable enables color in AUTO mode"
    - "ANSI constants defined for green, yellow, red, cyan, bold, dim, reset"
    - "colorize() helper wraps text with ANSI codes only when color enabled"
  artifacts:
    - path: "file_matcher.py"
      provides: "ColorConfig class and ANSI color infrastructure"
      contains: "class ColorConfig"
  key_links:
    - from: "ColorConfig.enabled"
      to: "os.environ.get('NO_COLOR')"
      via: "environment check in AUTO mode"
      pattern: "NO_COLOR"
---

<objective>
Implement ColorConfig class, ANSI constants, and colorize helper functions

Purpose: Foundation for TTY-aware color output. ColorConfig encapsulates all color decision logic (mode, environment variables, TTY detection). ANSI constants define the 16-color palette. Colorize helpers provide clean API for applying color conditionally.

Output: Modified file_matcher.py with color infrastructure (no visible output changes yet - formatters use it in plan 02)
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/08-color-enhancement/08-CONTEXT.md
@.planning/phases/08-color-enhancement/08-RESEARCH.md
@file_matcher.py (lines 1-30 for imports section)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add ANSI color constants</name>
  <files>file_matcher.py</files>
  <action>
  Add ANSI escape code constants after the imports section (around line 26, after the logger definition). Use 16-color SGR codes for maximum terminal compatibility.

  ```python
  # ============================================================================
  # ANSI Color Constants (16-color for compatibility)
  # ============================================================================

  # Reset
  RESET = "\033[0m"

  # Foreground colors (per 08-CONTEXT.md color palette)
  GREEN = "\033[32m"      # Masters (protected files)
  YELLOW = "\033[33m"     # Duplicates (removal candidates)
  RED = "\033[31m"        # Warnings and errors
  CYAN = "\033[36m"       # Statistics and summaries

  # Styles
  BOLD = "\033[1m"        # Emphasis
  DIM = "\033[2m"         # De-emphasis (hash values)

  # Compound styles
  BOLD_YELLOW = "\033[1;33m"  # PREVIEW MODE banner
  ```

  Place these AFTER the logger definition and BEFORE the Output Formatter ABCs section.
  </action>
  <verify>
  Run: `python3 -c "from file_matcher import GREEN, RESET; print(f'{GREEN}test{RESET}')"`
  Expected: "test" printed in green (on TTY terminals)

  Run: `python3 -c "import file_matcher; print('OK')"`
  Expected: No import errors
  </verify>
  <done>
  ANSI color constants defined: RESET, GREEN, YELLOW, RED, CYAN, BOLD, DIM, BOLD_YELLOW.
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement ColorMode enum and ColorConfig class</name>
  <files>file_matcher.py</files>
  <action>
  Add ColorMode enum and ColorConfig class after the ANSI constants (before the Output Formatter ABCs section).

  First, add the enum import to the imports section (around line 14):
  ```python
  from enum import Enum
  ```

  Then add the ColorMode enum and ColorConfig class:

  ```python
  # ============================================================================
  # Color Configuration
  # ============================================================================

  class ColorMode(Enum):
      """Color output mode."""
      AUTO = "auto"      # Enable color if TTY and no NO_COLOR
      NEVER = "never"    # Never use color
      ALWAYS = "always"  # Always use color (even in pipes)


  class ColorConfig:
      """Determines whether to use color based on mode, environment, and TTY.

      Follows NO_COLOR standard (https://no-color.org/) and common CLI conventions.

      Priority order:
      1. Explicit mode (NEVER or ALWAYS) from --color/--no-color flags
      2. NO_COLOR environment variable (disables color)
      3. FORCE_COLOR environment variable (enables color, for CI systems)
      4. TTY detection on the output stream
      """

      def __init__(
          self,
          mode: ColorMode = ColorMode.AUTO,
          stream: object = None
      ):
          """Initialize color configuration.

          Args:
              mode: Color mode (AUTO, NEVER, ALWAYS)
              stream: Output stream for TTY detection (default: sys.stdout)
          """
          self.mode = mode
          self.stream = stream if stream is not None else sys.stdout
          self._enabled: bool | None = None

      @property
      def enabled(self) -> bool:
          """Determine if color should be used.

          Returns:
              True if color output should be used, False otherwise.
          """
          # Use cached value if already computed
          if self._enabled is not None:
              return self._enabled

          # NEVER mode: always disabled
          if self.mode == ColorMode.NEVER:
              self._enabled = False
              return False

          # ALWAYS mode: always enabled (explicit user intent overrides environment)
          if self.mode == ColorMode.ALWAYS:
              self._enabled = True
              return True

          # AUTO mode: check environment and TTY
          # NO_COLOR takes precedence (standard compliance)
          if os.environ.get('NO_COLOR'):
              self._enabled = False
              return False

          # FORCE_COLOR enables (used by CI systems like GitHub Actions)
          if os.environ.get('FORCE_COLOR'):
              self._enabled = True
              return True

          # TTY detection
          try:
              self._enabled = self.stream.isatty()
          except AttributeError:
              self._enabled = False

          return self._enabled

      def reset(self) -> None:
          """Reset cached enabled state (for testing)."""
          self._enabled = None
  ```

  Note: The `stream` parameter allows per-stream color config (stdout vs stderr can have different color states when redirected independently).
  </action>
  <verify>
  Run: `python3 -c "from file_matcher import ColorConfig, ColorMode; cc = ColorConfig(ColorMode.NEVER); print(cc.enabled)"`
  Expected: False

  Run: `python3 -c "from file_matcher import ColorConfig, ColorMode; cc = ColorConfig(ColorMode.ALWAYS); print(cc.enabled)"`
  Expected: True

  Run: `python3 -c "import os; os.environ['NO_COLOR']='1'; from file_matcher import ColorConfig, ColorMode; cc = ColorConfig(); print(cc.enabled)"`
  Expected: False (NO_COLOR respected)
  </verify>
  <done>
  ColorMode enum and ColorConfig class implemented with NO_COLOR/FORCE_COLOR support and TTY detection.
  </done>
</task>

<task type="auto">
  <name>Task 3: Implement colorize helper functions</name>
  <files>file_matcher.py</files>
  <action>
  Add colorize helper functions after the ColorConfig class (before Output Formatter ABCs).

  ```python
  # ============================================================================
  # Color Helper Functions
  # ============================================================================

  def colorize(text: str, code: str, color_config: ColorConfig) -> str:
      """Wrap text with ANSI color code if color is enabled.

      Args:
          text: Text to colorize
          code: ANSI escape code (e.g., GREEN, BOLD)
          color_config: ColorConfig instance determining if color is enabled

      Returns:
          Colorized text if enabled, original text otherwise.
      """
      if not color_config.enabled:
          return text
      return f"{code}{text}{RESET}"


  def green(text: str, cc: ColorConfig) -> str:
      """Color text green (masters, protected files)."""
      return colorize(text, GREEN, cc)


  def yellow(text: str, cc: ColorConfig) -> str:
      """Color text yellow (duplicates, removal candidates)."""
      return colorize(text, YELLOW, cc)


  def red(text: str, cc: ColorConfig) -> str:
      """Color text red (warnings, errors)."""
      return colorize(text, RED, cc)


  def cyan(text: str, cc: ColorConfig) -> str:
      """Color text cyan (statistics, summaries)."""
      return colorize(text, CYAN, cc)


  def dim(text: str, cc: ColorConfig) -> str:
      """Dim text (hash values, de-emphasized content)."""
      return colorize(text, DIM, cc)


  def bold(text: str, cc: ColorConfig) -> str:
      """Bold text (emphasis)."""
      return colorize(text, BOLD, cc)


  def bold_yellow(text: str, cc: ColorConfig) -> str:
      """Bold yellow text (PREVIEW MODE banner)."""
      return colorize(text, BOLD_YELLOW, cc)
  ```

  These helpers provide a clean API for formatters to apply semantic coloring without dealing with ANSI codes directly.
  </action>
  <verify>
  Run: `python3 -c "from file_matcher import green, ColorConfig, ColorMode; cc = ColorConfig(ColorMode.ALWAYS); print(repr(green('test', cc)))"`
  Expected: Contains '\033[32m' and '\033[0m'

  Run: `python3 -c "from file_matcher import green, ColorConfig, ColorMode; cc = ColorConfig(ColorMode.NEVER); print(repr(green('test', cc)))"`
  Expected: 'test' (no ANSI codes)

  Run: `python3 run_tests.py`
  Expected: All tests pass (no regressions from adding color infrastructure)
  </verify>
  <done>
  Colorize helper functions implemented: colorize(), green(), yellow(), red(), cyan(), dim(), bold(), bold_yellow(). All existing tests pass.
  </done>
</task>

</tasks>

<verification>
Overall phase checks:

1. ANSI constants available:
   - `python3 -c "from file_matcher import GREEN, YELLOW, RED, CYAN, BOLD, DIM, RESET, BOLD_YELLOW; print('OK')"`

2. ColorConfig works:
   - `python3 -c "from file_matcher import ColorConfig, ColorMode; cc = ColorConfig(); print(type(cc.enabled))"`
   - Should print `<class 'bool'>`

3. NO_COLOR environment variable respected:
   - `NO_COLOR=1 python3 -c "from file_matcher import ColorConfig; cc = ColorConfig(); print(cc.enabled)"`
   - Should print `False`

4. Helper functions work:
   - `python3 -c "from file_matcher import green, ColorConfig, ColorMode; print(green('test', ColorConfig(ColorMode.ALWAYS)))"`
   - Should print colored "test" on terminal

5. All existing tests pass:
   - `python3 run_tests.py`
</verification>

<success_criteria>
- ColorMode enum defined with AUTO, NEVER, ALWAYS values
- ColorConfig class determines color state from mode, environment, and stream TTY
- NO_COLOR environment variable disables color in AUTO mode
- FORCE_COLOR environment variable enables color in AUTO mode
- ANSI constants defined: RESET, GREEN, YELLOW, RED, CYAN, BOLD, DIM, BOLD_YELLOW
- Colorize helper functions: colorize(), green(), yellow(), red(), cyan(), dim(), bold(), bold_yellow()
- All existing tests pass (no regressions)
- No visible output changes yet (formatters integrated in plan 02)
</success_criteria>

<output>
After completion, create `.planning/phases/08-color-enhancement/08-01-SUMMARY.md`
</output>
