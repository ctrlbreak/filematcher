# Phase 20.1: JSON Header Object Format - Research

**Researched:** 2026-01-30
**Domain:** JSON schema design, CLI output structure, breaking change management
**Confidence:** HIGH

## Summary

This phase restructures the JSON output to consolidate metadata into a unified `header` object and standardize directory naming across compare and action modes. The current implementation scatters metadata (timestamp, mode, action, directories, hashAlgorithm) at the root level with inconsistent naming between modes (dir1/dir2 in compare mode vs master/duplicate in action mode).

The primary change is structural, not functional. The JSON content remains the same but reorganized for better machine parsing and consistency. This follows established patterns from tools like Terraform that use a top-level metadata object with version identification.

**Primary recommendation:** Implement a `header` object containing `name`, `version`, `timestamp`, `mode`, `action`, `hashAlgorithm`, and `directories` with unified `master`/`duplicate` keys. Keep data arrays (`matches`, `duplicateGroups`) at root level.

## Standard Stack

This phase requires no additional libraries. The existing Python standard library `json` module is sufficient.

### Core
| Library | Version | Purpose | Why Standard |
|---------|---------|---------|--------------|
| json | stdlib | JSON serialization | Built into Python, no external dependencies needed |
| dataclasses | stdlib | Structure header data | Already used in project for SpaceInfo, etc. |

### Supporting
N/A - Pure refactoring of existing JSON serialization code.

### Alternatives Considered
| Instead of | Could Use | Tradeoff |
|------------|-----------|----------|
| Nested header object | JSON:API format | JSON:API is overkill for CLI tool output; simpler header pattern is more appropriate |
| Custom versioning | Semantic versioning | Use simple format_version like Terraform for CLI tools |

## Architecture Patterns

### Recommended JSON Structure

**Compare Mode (current):**
```json
{
  "timestamp": "2026-01-30T12:00:00+00:00",
  "directories": {
    "dir1": "/path/to/master",
    "dir2": "/path/to/duplicate"
  },
  "hashAlgorithm": "md5",
  "matches": [...],
  "unmatchedDir1": [],
  "unmatchedDir2": [],
  "summary": {...},
  "statistics": {...}
}
```

**Compare Mode (proposed):**
```json
{
  "header": {
    "name": "filematcher",
    "version": "2.0",
    "timestamp": "2026-01-30T12:00:00+00:00",
    "mode": "compare",
    "hashAlgorithm": "md5",
    "directories": {
      "master": "/path/to/master",
      "duplicate": "/path/to/duplicate"
    }
  },
  "matches": [...],
  "unmatchedMaster": [],
  "unmatchedDuplicate": [],
  "summary": {...},
  "statistics": {...}
}
```

**Action Mode (current):**
```json
{
  "timestamp": "2026-01-30T12:00:00+00:00",
  "mode": "preview",
  "action": "hardlink",
  "directories": {
    "master": "/path/to/master",
    "duplicate": "/path/to/duplicate"
  },
  "warnings": [],
  "duplicateGroups": [...],
  "statistics": {...}
}
```

**Action Mode (proposed):**
```json
{
  "header": {
    "name": "filematcher",
    "version": "2.0",
    "timestamp": "2026-01-30T12:00:00+00:00",
    "mode": "preview",
    "action": "hardlink",
    "hashAlgorithm": "md5",
    "directories": {
      "master": "/path/to/master",
      "duplicate": "/path/to/duplicate"
    }
  },
  "warnings": [],
  "duplicateGroups": [...],
  "statistics": {...},
  "execution": {...}
}
```

### Pattern 1: Header Object Pattern (Terraform-style)

**What:** Consolidate all metadata into a top-level `header` object with a `version` field for schema evolution.

**When to use:** CLI tools that emit JSON for machine consumption and need forward-compatible schema versioning.

**Example:**
```python
# Source: Terraform JSON output pattern (terraform-json package)
header = {
    "name": "filematcher",
    "version": "2.0",  # Schema version, not tool version
    "timestamp": datetime.now(timezone.utc).isoformat(),
    "mode": mode,
    "action": action,
    "hashAlgorithm": hash_algorithm,
    "directories": {
        "master": str(Path(dir1).resolve()),
        "duplicate": str(Path(dir2).resolve())
    }
}
```

### Pattern 2: Unified Directory Naming

**What:** Use `master` and `duplicate` consistently in both compare and action modes instead of `dir1`/`dir2`.

**When to use:** When the same conceptual entities have different names in different contexts.

**Example:**
```python
# Before: Inconsistent naming
compare_mode: {"dir1": ..., "dir2": ...}
action_mode: {"master": ..., "duplicate": ...}

# After: Unified naming
all_modes: {"master": ..., "duplicate": ...}
```

### Anti-Patterns to Avoid

- **Mixing metadata and data at same level:** Keep header separate from data arrays (matches, duplicateGroups).
- **Tool version as schema version:** Use a separate `version` field for the JSON schema format, not the tool version (tool version can change without schema changes).
- **Breaking changes without version bump:** Always increment schema version when structure changes.

## Don't Hand-Roll

This phase involves refactoring existing code, no new complex problems to solve.

| Problem | Don't Build | Use Instead | Why |
|---------|-------------|-------------|-----|
| JSON serialization | Custom encoder | Python json module | Already in use, battle-tested |
| Timestamp formatting | Manual string building | datetime.isoformat() | Already in use, RFC 3339 compliant |

## Common Pitfalls

### Pitfall 1: Breaking Existing Consumers Without Warning

**What goes wrong:** JSON consumers (scripts, CI/CD) break when schema changes without notice.
**Why it happens:** Schema changes look "minor" but field moves/renames break `jq` queries.
**How to avoid:**
- Document breaking changes in CHANGELOG and release notes
- Bump schema version in header
- Consider deprecation period if tool is widely used
**Warning signs:** Users complaining about scripts breaking after upgrade.

### Pitfall 2: Inconsistent Naming After Refactor

**What goes wrong:** Some code paths still emit old field names (dir1/dir2).
**Why it happens:** Not all code paths through JsonActionFormatter are tested.
**How to avoid:**
- Update ALL test cases to verify new structure
- Test both compare and action modes explicitly
- Test with --verbose, --show-unmatched, and combinations
**Warning signs:** Tests pass but jq queries fail in production.

### Pitfall 3: Forgetting to Update finalize() Method

**What goes wrong:** Header object not included in final output.
**Why it happens:** JsonActionFormatter builds output in `finalize()` which has separate logic for compare vs action modes.
**How to avoid:**
- Update both code paths in `finalize()`
- Create shared helper for header construction
**Warning signs:** Different structure between compare and action JSON output.

### Pitfall 4: Version Field Confusion

**What goes wrong:** Consumers interpret schema version as tool version.
**Why it happens:** Field named "version" without context.
**How to avoid:**
- Add "name": "filematcher" alongside version
- Document that version is JSON schema version, not tool version
- Consider "schemaVersion" or "formatVersion" naming
**Warning signs:** Bug reports expecting tool features based on version field.

## Code Examples

### Current JsonActionFormatter Structure

From `filematcher/formatters.py`:

```python
# Current initialization
self._data: dict = {
    "timestamp": datetime.now(timezone.utc).isoformat(),
    "mode": "preview" if preview_mode else "execute",
    "action": "",
    "directories": {
        "master": "",
        "duplicate": ""
    },
    "warnings": [],
    "duplicateGroups": [],
    "statistics": {}
}
```

### Proposed Header Helper Function

```python
def build_json_header(
    mode: str,
    action: str | None,
    hash_algorithm: str,
    master_dir: str,
    duplicate_dir: str
) -> dict:
    """Build the unified header object for JSON output.

    Args:
        mode: "compare", "preview", or "execute"
        action: Action type or None for compare mode
        hash_algorithm: "md5" or "sha256"
        master_dir: Path to master directory
        duplicate_dir: Path to duplicate directory

    Returns:
        Header dict with all metadata
    """
    header = {
        "name": "filematcher",
        "version": "2.0",
        "timestamp": datetime.now(timezone.utc).isoformat(),
        "mode": mode,
        "hashAlgorithm": hash_algorithm,
        "directories": {
            "master": str(Path(master_dir).resolve()),
            "duplicate": str(Path(duplicate_dir).resolve())
        }
    }
    if action and action != "compare":
        header["action"] = action
    return header
```

### Updated finalize() Pattern

```python
def finalize(self) -> None:
    """Build and print final JSON output."""
    header = build_json_header(
        mode=self._mode,
        action=self._action,
        hash_algorithm=self._hash_algorithm,
        master_dir=self._master_dir,
        duplicate_dir=self._duplicate_dir
    )

    output = {"header": header}

    if self._action == "compare":
        output["matches"] = self._matches
        output["unmatchedMaster"] = self._unmatched_master
        output["unmatchedDuplicate"] = self._unmatched_duplicate
        output["summary"] = self._summary
        output["statistics"] = self._statistics
    else:
        output["warnings"] = self._warnings
        output["duplicateGroups"] = self._duplicate_groups
        output["statistics"] = self._statistics
        if self._execution:
            output["execution"] = self._execution

    print(json.dumps(output, indent=2))
```

### Test Migration Pattern

```python
# Before: Testing root-level fields
def test_json_has_required_fields(self):
    required_fields = ['timestamp', 'directories', 'hashAlgorithm', 'matches', 'summary']
    for field in required_fields:
        self.assertIn(field, data)

# After: Testing header object + root arrays
def test_json_has_required_structure(self):
    self.assertIn('header', data)
    header = data['header']

    header_fields = ['name', 'version', 'timestamp', 'mode', 'hashAlgorithm', 'directories']
    for field in header_fields:
        self.assertIn(field, header)

    self.assertIn('master', header['directories'])
    self.assertIn('duplicate', header['directories'])

    # Data arrays at root
    self.assertIn('matches', data)
    self.assertIn('summary', data)
```

## State of the Art

| Old Approach | Current Approach | When Changed | Impact |
|--------------|------------------|--------------|--------|
| Flat metadata at root | Header object with version | Common in CLI tools circa 2024+ | Better forward compatibility |
| dir1/dir2 naming | master/duplicate naming | This refactor | Consistency with action mode |
| No schema version | format_version in header | Terraform pattern | Enables schema evolution |

**Deprecated/outdated:**
- Root-level timestamp/directories/mode: Moving to header object
- dir1/dir2 keys in compare mode: Replaced with master/duplicate

## Open Questions

1. **Schema Version Naming**
   - What we know: Options are `version`, `schemaVersion`, or `formatVersion`
   - What's unclear: Project preference for naming convention
   - Recommendation: Use `version` with `name: "filematcher"` context (simpler, matches JSON:API pattern)

2. **Version Number Scheme**
   - What we know: Could use semver (2.0.0) or simple (2.0) or date-based
   - What's unclear: What version to start with given this is first structured schema
   - Recommendation: Start with `"2.0"` to indicate breaking change from implicit v1

3. **Unmatched Field Renaming**
   - What we know: Current `unmatchedDir1`/`unmatchedDir2` should probably be `unmatchedMaster`/`unmatchedDuplicate`
   - What's unclear: Whether this is too many changes at once
   - Recommendation: Include in this phase since it's already a breaking change; unify all naming together

4. **Metadata Location for Verbose Mode**
   - What we know: `--verbose` adds `metadata` object at root currently
   - What's unclear: Should metadata stay at root or move under header?
   - Recommendation: Keep `metadata` at root level (it's per-file data, not run metadata)

## Sources

### Primary (HIGH confidence)
- `filematcher/formatters.py` - Current JSON implementation (lines 238-509)
- `tests/test_json_output.py` - Current JSON test suite (228 lines, comprehensive)
- Terraform JSON patterns via terraform-json package documentation

### Secondary (MEDIUM confidence)
- [JSON:API v1.1 specification](https://jsonapi.org/format/) - Header/meta object patterns
- [Terraform providers schema](https://developer.hashicorp.com/terraform/tutorials/cli/plan) - format_version pattern

### Tertiary (LOW confidence)
- General web search for CLI JSON versioning patterns

## Metadata

**Confidence breakdown:**
- Standard stack: HIGH - No new libraries needed, pure refactoring
- Architecture: HIGH - Pattern well-established in Terraform and JSON:API
- Pitfalls: HIGH - Based on direct analysis of existing codebase

**Research date:** 2026-01-30
**Valid until:** 60 days (stable patterns, internal refactoring)
